<!DOCTYPE html>
<html lang="en">
<!--
   üîß SYNTAX ERROR FIXED!
   
   Problem: dris_RESTORE_244K had 6 extra closing braces in STUDIO module
   Solution: Replaced broken STUDIO JavaScript with working version from dris_SAFE_BACKUP_140K
   
   What you get:
   ‚úÖ Working AUDIO_STUDIO (from 140K - no syntax errors)
   ‚úÖ Perfect intro screen + navigation (from 244K)
   ‚úÖ MOTION_AI + VISUAL_LAB (from 244K)
   ‚úÖ Theme color picker (from 244K)
   
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   ‚úèÔ∏è WORKING COPY - Modify Freely!
   
   This is your working copy. Experiment and make changes here!
   
   If you mess something up:
   1. Delete this file
   2. Copy dris_LOCKED_BACKUP_v1.0.html
   3. Rename the copy to dris_WORKING_COPY.html
   4. Start fresh!
   
   Original backup is always safe at: dris_LOCKED_BACKUP_v1.0.html
   
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DRIS | DEEP_GRANULAR_LAB</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=JetBrains+Mono&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* INTRO PAGE STYLES */
        :root { 
            --accent: #00ff85;
            --bg: #030303;
        }
        
        /* THEME VARIANTS */
        :root[data-theme="cyan"] {
            --accent: #00d4ff;
        }
        
        :root[data-theme="purple"] {
            --accent: #d946ef;
        }
        
        :root[data-theme="red"] {
            --accent: #ff0055;
        }
        
        :root[data-theme="orange"] {
            --accent: #ff6b00;
        }
        
        :root[data-theme="yellow"] {
            --accent: #ffed00;
        }
        
        :root[data-theme="pink"] {
            --accent: #ff71ce;
        }
        
        :root[data-theme="white"] {
            --accent: #ffffff;
        }
        
        /* SCANLINE EFFECT */
        body::after { 
            content: ""; 
            position: fixed; 
            inset: 0; 
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.04), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.04)); 
            z-index: 99999; 
            background-size: 100% 2px, 3px 100%; 
            pointer-events: none; 
        }

        /* CURSOR */
        #cursor-main { width: 12px; height: 12px; background: #fff; border-radius: 50%; position: fixed; pointer-events: none; z-index: 100000; transform: translate(-50%, -50%); mix-blend-mode: difference; }
        #axis-h, #axis-v { position: fixed; background: rgba(255,255,255,0.08); pointer-events: none; z-index: 99998; }
        #axis-h { width: 100%; height: 1px; } 
        #axis-v { height: 100%; width: 1px; }

        /* BOOT SCREEN */
        #gate { position: fixed; inset: 0; z-index: 99999; background: var(--bg); display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #gate h1 { 
            font-family: 'Bebas Neue'; 
            font-size: 15vw; 
            margin-bottom: 40px; 
            letter-spacing: -5px;
            color: #fff;
        }
        .btn-tech { border: 1px solid rgba(255,255,255,0.2); padding: 15px 40px; font-family: 'Bebas Neue'; background: transparent; color: #fff; transition: 0.3s; cursor: pointer; letter-spacing: 8px; font-size: 18px; }
        .btn-tech:hover { 
            background: #fff; 
            color: #000; 
            box-shadow: 0 0 30px var(--accent); 
            animation: treble 0.08s infinite;
        }

        @keyframes treble {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(-1px, 1px) rotate(-0.5deg); }
            50% { transform: translate(1px, -1px) rotate(0.5deg); }
            75% { transform: translate(-1px, -1px) rotate(-0.3deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }
        
        /* THEME SELECTOR */
        .theme-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid rgba(255,255,255,0.2);
            transition: all 0.3s;
            position: relative;
        }
        
        .theme-dot:hover {
            transform: scale(1.3);
            border-color: #fff;
            box-shadow: 0 0 20px currentColor;
        }
        
        .theme-dot.active {
            border-color: #fff;
            box-shadow: 0 0 20px currentColor;
            transform: scale(1.2);
        }
        
        .theme-dot.active::after {
            content: '';
            position: absolute;
            inset: -8px;
            border: 2px solid currentColor;
            border-radius: 50%;
        }

        /* NAVIGATION MENU */
        #ui-root { 
            position: fixed; 
            inset: 0; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            padding: 0 10vw; 
            opacity: 0; 
            z-index: 99997; 
            background: var(--bg); 
        }
        
        @keyframes jitter {
            0% { transform: translate(0,0); }
            10% { transform: translate(-2px, 1px); }
            90% { transform: translate(2px, -1px); }
            100% { transform: translate(0,0); }
        }
        
        .nav-item { 
            font-family: 'Bebas Neue'; 
            font-size: 10vw; 
            line-height: 0.8; 
            opacity: 0.05; 
            transition: 0.6s cubic-bezier(0.075, 0.82, 0.165, 1); 
            cursor: pointer;
            letter-spacing: 2px;
        }
        .nav-item:hover { 
            opacity: 1; 
            color: var(--accent); 
            letter-spacing: 15px; 
            animation: jitter 0.05s infinite;
            text-shadow: 0 0 20px var(--accent), 0 0 40px var(--accent), 0 0 60px var(--accent);
        }

        /* STUDIO CONTAINER */
        #studio-container {
            display: none;
            position: relative;
            z-index: 1;
        }
        
        #studio-container.active { 
            display: block; 
        }

        .exit-studio-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            padding: 10px 20px;
            background: transparent;
            border: 1px solid #00ff85;
            color: #00ff85;
            font-family: 'Bebas Neue';
            font-size: 14px;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .exit-studio-btn:hover {
            background: #00ff85;
            color: #000;
            box-shadow: 0 0 10px rgba(0, 255, 133, 0.3);
        }

        /* STUDIO STYLES */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(135deg, #0a0a0a 0%, #141414 50%, #0a0a0a 100%);
            border-bottom: 2px solid var(--accent);
            padding: 40px 20px;
            text-align: center;
            position: relative;
            box-shadow: 0 0 30px rgba(0, 255, 133, 0.1);
        }

        .logo {
            font-family: 'Bebas Neue';
            font-size: 72px;
            color: var(--accent);
            letter-spacing: 16px;
            margin-bottom: 5px;
            font-weight: 400;
            text-shadow: 0 0 20px var(--accent);
        }

        .tagline {
            font-size: 11px;
            color: var(--accent);
            letter-spacing: 6px;
            text-transform: uppercase;
            opacity: 0.6;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .section {
            background: linear-gradient(135deg, #0d0d0d 0%, #1a1a1a 50%, #0d0d0d 100%);
            border: 1px solid var(--accent);
            padding: 40px;
            margin-bottom: 30px;
            border-radius: 8px;
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 133, 0.05);
            transition: all 0.3s;
        }
        
        .section:hover {
            box-shadow: 0 0 30px rgba(0, 255, 133, 0.15);
        }

        .section-title {
            font-family: 'Bebas Neue';
            font-size: 28px;
            color: var(--accent);
            margin-bottom: 20px;
            letter-spacing: 4px;
            text-transform: uppercase;
            border-left: 4px solid var(--accent);
            padding-left: 15px;
            text-shadow: 0 0 10px var(--accent);
        }

        .section-subtitle {
            font-size: 11px;
            color: var(--accent);
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
        }

        /* CONTROLS */
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 10px 20px;
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            font-family: 'Bebas Neue';
            font-size: 14px;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(0, 255, 133, 0.1);
            box-shadow: 0 0 15px var(--accent);
            text-shadow: 0 0 5px var(--accent);
        }

        .btn.active {
            background: var(--accent);
            color: #000;
            box-shadow: 0 0 20px var(--accent);
        }
        
        .btn-small {
            padding: 8px 16px;
            font-size: 12px;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
        }

        select.btn {
            cursor: pointer;
            appearance: none;
            padding-right: 30px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2300ff85' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
        }

        input[type="range"] {
            width: 200px;
            height: 6px;
            background: #222;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #00ff85;
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #00ff85;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .label {
            font-family: 'Bebas Neue';
            font-size: 14px;
            letter-spacing: 2px;
            color: #666;
            min-width: 80px;
        }

        .value {
            font-family: 'Bebas Neue';
            font-size: 18px;
            color: #00ff85;
            min-width: 80px;
        }

        /* SEQUENCER */
        .sequencer {
            display: grid;
            gap: 8px;
        }

        .track {
            display: grid;
            grid-template-columns: 100px repeat(16, 1fr);
            gap: 3px;
            align-items: center;
        }

        .track-name {
            font-family: 'Bebas Neue';
            font-size: 14px;
            letter-spacing: 2px;
            color: #666;
        }

        .step {
            aspect-ratio: 1;
            background: #1a1a1a;
            border: 2px solid #2a2a2a;
            cursor: pointer;
            transition: all 0.1s;
            position: relative;
        }

        .step:hover {
            border-color: #00ff85;
        }

        .step.active {
            background: rgba(0, 255, 133, 0.3);
            border-color: #00ff85;
        }

        .step.playing {
            background: #00ff85;
            box-shadow: 0 0 15px #00ff85;
        }

        .step.beat-4 {
            border-right: 3px solid #333;
        }

        /* BASS SEQUENCER */
        .bass-track {
            display: grid;
            grid-template-columns: 100px repeat(16, 1fr);
            gap: 3px;
            align-items: stretch;
            margin-bottom: 10px;
        }

        .bass-step {
            aspect-ratio: 1;
            background: #1a1a1a;
            border: 2px solid #2a2a2a;
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            min-height: 80px;
        }

        .bass-step:hover {
            border-color: #00ff85;
        }

        .bass-step.active {
            border-color: #00ff85;
        }

        .bass-step.beat-4 {
            border-right: 3px solid #333;
        }

        .bass-bar {
            width: 100%;
            background: linear-gradient(to top, #00ff85, rgba(0, 255, 133, 0.3));
            transition: height 0.1s;
            position: relative;
        }

        .bass-note-label {
            position: absolute;
            top: 2px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 9px;
            color: #00ff85;
            font-family: 'JetBrains Mono';
        }

        .bass-step.playing {
            border-color: #00ff85;
            box-shadow: 0 0 15px #00ff85;
        }

        /* SYNTH PANEL */
        .synth-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .param {
            background: #1a1a1a;
            padding: 15px;
            border: 1px solid #2a2a2a;
        }

        .param-label {
            font-family: 'Bebas Neue';
            font-size: 12px;
            letter-spacing: 2px;
            color: #666;
            margin-bottom: 10px;
        }

        .param-value {
            color: #00ff85;
            font-size: 16px;
            margin-top: 5px;
        }

        /* CANVAS */
        .canvas-container {
            width: 100%;
            height: 400px;
            background: #000;
            border: 2px solid #00ff85;
            position: relative;
            cursor: crosshair;
            overflow: hidden;
        }

        .canvas-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 1px solid #00ff85;
            font-size: 12px;
            z-index: 10;
        }

        /* CODE EDITOR */
        .code-editor {
            background: #0d0d0d;
            border: 2px solid #2a2a2a;
            padding: 20px;
            font-family: 'JetBrains Mono';
            font-size: 14px;
            height: 300px;
            overflow-y: auto;
            position: relative;
        }

        .code-input {
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
            outline: none;
            color: #00ff85;
            font-family: 'JetBrains Mono';
            resize: none;
            line-height: 1.6;
        }

        .code-output {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 255, 133, 0.05);
            border: 1px solid #00ff85;
            font-family: 'JetBrains Mono';
            font-size: 12px;
            min-height: 80px;
            max-height: 200px;
            overflow-y: auto;
        }

        /* VIDEO DISPLAY */
        .video-container {
            width: 100%;
            height: 500px;
            background: #000;
            border: 2px solid #00ff85;
            position: relative;
            overflow: hidden;
        }

        .video-container video,
        .video-container canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 20px;
        }

        .loading-overlay.active {
            display: flex;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #2a2a2a;
            border-top-color: #00ff85;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .input-text {
            width: 100%;
            max-width: 600px;
            padding: 15px;
            background: #1a1a1a;
            border: 2px solid #2a2a2a;
            color: #fff;
            font-family: 'JetBrains Mono';
            font-size: 14px;
            outline: none;
            margin-bottom: 20px;
        }

        .input-text:focus {
            border-color: #00ff85;
        }

        .input-text::placeholder {
            color: #555;
        }

        /* RESPONSIVE */
        @media (max-width: 768px) {
            .logo {
                font-size: 40px;
            }
            
            .section {
                padding: 20px;
            }
            
            .track,
            .bass-track {
                grid-template-columns: 80px repeat(16, 1fr);
            }
        }

        /* FOOTER */
        .footer {
            text-align: center;
            padding: 40px 20px;
            color: #666;
            font-size: 12px;
        }

        .social-links {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
        }

        .social-links a {
            color: #00ff85;
            text-decoration: none;
            font-family: 'Bebas Neue';
            letter-spacing: 2px;
            transition: all 0.3s;
        }

        .social-links a:hover {
            text-shadow: 0 0 10px #00ff85;
        }
    </style>
</head>
<body style="cursor: none;">
    <!-- CUSTOM CURSOR -->
    <div id="axis-h"></div>
    <div id="axis-v"></div>
    <div id="cursor-main"></div>

    <!-- BOOT SCREEN -->
    <div id="gate">
        <h1>DRIS_LABS</h1>
        
        <!-- THEME SELECTOR -->
        <div style="display: flex; gap: 10px; margin-bottom: 30px;">
            <div class="theme-dot" data-theme="default" style="background: #00ff85;" title="GREEN"></div>
            <div class="theme-dot" data-theme="cyan" style="background: #00d4ff;" title="CYAN"></div>
            <div class="theme-dot" data-theme="purple" style="background: #d946ef;" title="PURPLE"></div>
            <div class="theme-dot" data-theme="red" style="background: #ff0055;" title="RED"></div>
            <div class="theme-dot" data-theme="orange" style="background: #ff6b00;" title="ORANGE"></div>
            <div class="theme-dot" data-theme="yellow" style="background: #ffed00;" title="YELLOW"></div>
            <div class="theme-dot" data-theme="pink" style="background: #ff71ce;" title="PINK"></div>
            <div class="theme-dot" data-theme="white" style="background: #ffffff;" title="WHITE"></div>
        </div>
        
        <button onclick="bootSystem()" class="btn-tech">ENGAGE_SYSTEM</button>
    </div>

    <!-- NAVIGATION MENU -->
    <main id="ui-root">
        <div class="nav-item" onclick="enterStudio()">AUDIO_STUDIO</div>
        <div class="nav-item" onclick="enterMotionAI()">MOTION_AI</div>
        <div class="nav-item" onclick="enterVisualLab()">VISUAL_LAB</div>
    </main>

    <!-- STUDIO CONTAINER (HIDDEN BY DEFAULT) -->
    <div id="studio-container">
        <button class="exit-studio-btn" onclick="exitStudio()">‚Üê EXIT</button>
        <button class="exit-studio-btn" onclick="showStudioHelp()" style="right: 120px;">? HELP</button>
        
    <div class="header">
        <div class="logo">DRIS_STUDIO</div>
        <div class="tagline">Audio Production Platform</div>
    </div>

    <div class="container">
        <!-- DRUM MACHINE -->
        <div class="section">
            <div class="section-title">Drum Machine</div>
            <div class="section-subtitle">AI-powered sequencer with probability and micro-timing</div>
            
            <div class="controls">
                <button class="btn" id="drum-play" onclick="STUDIO.toggleDrums()">PLAY</button>
                <button class="btn" onclick="STUDIO.clearDrums()">CLEAR</button>
                <button class="btn" onclick="STUDIO.generateDrumPattern()">AI GENERATE</button>
                
                <div class="control-group">
                    <span class="label">KIT:</span>
                    <select class="btn" id="drum-kit" onchange="STUDIO.setDrumKit(this.value)">
                        <option value="909">909 CLASSIC</option>
                        <option value="808">808 DEEP</option>
                        <option value="trap">TRAP</option>
                        <option value="lofi">LO-FI</option>
                        <option value="glitch">GLITCH IDM</option>
                        <option value="broken">BROKEN BEAT</option>
                        <option value="aphex">APHEX TWIN</option>
                        <option value="cartoon">CARTOON</option>
                        <option value="industrial">INDUSTRIAL</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <span class="label">BPM:</span>
                    <input type="range" id="drum-tempo" min="60" max="200" value="120" oninput="STUDIO.setDrumTempo(this.value)">
                    <span class="value" id="drum-tempo-val">120</span>
                </div>
                
                <div class="control-group">
                    <span class="label">HUMANIZE:</span>
                    <input type="range" id="humanize" min="0" max="100" value="0" oninput="STUDIO.setHumanize(this.value)">
                    <span class="value" id="humanize-val">0%</span>
                </div>
            </div>

            <div class="sequencer" id="drum-sequencer"></div>
            
            <div style="margin-top: 15px; padding: 10px; background: #0a0a0a; border-left: 2px solid #00ff85; font-size: 10px; color: #666;">
                <strong style="color: #00ff85;">PRO TIP:</strong> Right-click steps to adjust probability (0-100%). Humanize adds micro-timing variations.
            </div>
        </div>

        <!-- BASSLINE MAKER -->
        <div class="section">
            <div class="section-title">Bassline Maker</div>
            <div class="section-subtitle">Compact note sequencer | Professional presets | Record your patterns</div>
            
            <div class="controls">
                <button class="btn" id="bass-play" onclick="STUDIO.toggleBass()">PLAY</button>
                <button class="btn" onclick="STUDIO.clearBass()">CLEAR</button>
                <button class="btn" onclick="STUDIO.randomBass()">RANDOM</button>
                <button class="btn" id="bass-record" onclick="STUDIO.recordBass()">‚óè RECORD</button>
                
                <div class="control-group">
                    <span class="label">PRESET:</span>
                    <select class="btn" id="bass-preset" onchange="STUDIO.loadBassPreset(this.value)">
                        <option value="">-- SELECT --</option>
                        <option value="techno">TECHNO GROOVE</option>
                        <option value="house">HOUSE PUMP</option>
                        <option value="dnb">DNB ROLLER</option>
                        <option value="acid">ACID 303</option>
                        <option value="minimal">MINIMAL DEEP</option>
                        <option value="trance">TRANCE ARPEGGIO</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <span class="label">WAVE:</span>
                    <select class="btn" id="bass-wave" onchange="STUDIO.setBassWave(this.value)">
                        <option value="sawtooth">SAW</option>
                        <option value="square">SQUARE</option>
                        <option value="triangle">TRIANGLE</option>
                        <option value="sine">SINE</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <span class="label">ROOT:</span>
                    <select class="btn" id="bass-root">
                        <option value="C">C</option>
                        <option value="D">D</option>
                        <option value="E">E</option>
                        <option value="F">F</option>
                        <option value="G">G</option>
                        <option value="A">A</option>
                        <option value="B">B</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <span class="label">SCALE:</span>
                    <select class="btn" id="bass-scale">
                        <option value="minor">MINOR</option>
                        <option value="major">MAJOR</option>
                        <option value="phrygian">PHRYGIAN</option>
                        <option value="dorian">DORIAN</option>
                    </select>
                </div>
            </div>

            <!-- BASS FILTER SECTION -->
            <div style="background: #0a0a0a; padding: 15px; margin: 15px 0; border-left: 3px solid var(--accent);">
                <div style="font-family: 'Bebas Neue'; font-size: 18px; letter-spacing: 2px; margin-bottom: 15px; color: var(--accent);">BASS FILTER</div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div class="control-group">
                        <span class="label">FILTER TYPE</span>
                        <select class="btn" id="bass-filter-type" onchange="STUDIO.setBassFilterType(this.value)">
                            <option value="lowpass">LOWPASS</option>
                            <option value="highpass">HIGHPASS</option>
                            <option value="bandpass">BANDPASS</option>
                            <option value="notch">NOTCH</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <span class="label">CUTOFF</span>
                        <input type="range" id="bass-filter-cutoff" min="20" max="5000" value="2000" oninput="STUDIO.setBassFilterCutoff(this.value)">
                        <span class="value" id="bass-cutoff-val">2000 Hz</span>
                    </div>
                    
                    <div class="control-group">
                        <span class="label">RESONANCE</span>
                        <input type="range" id="bass-filter-res" min="0" max="30" value="1" step="0.1" oninput="STUDIO.setBassFilterResonance(this.value)">
                        <span class="value" id="bass-res-val">1.0</span>
                    </div>
                    
                    <div class="control-group">
                        <span class="label">ENVELOPE</span>
                        <input type="range" id="bass-filter-env" min="0" max="5000" value="0" oninput="STUDIO.setBassFilterEnvelope(this.value)">
                        <span class="value" id="bass-env-val">0 Hz</span>
                    </div>
                </div>
            </div>

            <div id="bass-sequencer" style="display: grid; grid-template-columns: repeat(16, 1fr); gap: 3px; margin-bottom: 15px; max-width: 100%; overflow-x: auto;"></div>
            
            <div class="info-box">
                <strong>BASS PRESETS:</strong> Professional patterns ready to use | <strong>CONTROLS:</strong> Click step to toggle | Drag up/down to change pitch | Double-click to remove | <strong>RECORD:</strong> Exports 4-bar loop as WAV file
            </div>
        </div>

        <!-- CURSOR SYNTH -->
        <div class="section">
            <div class="section-title">Cursor Synth</div>
            <div class="section-subtitle">X-axis controls frequency, Y-axis controls filter cutoff</div>
            
            <div class="canvas-container" id="synth-canvas">
                <div class="canvas-info">
                    <div>FREQ: <span id="synth-freq">--</span> Hz</div>
                    <div>FILTER: <span id="synth-filter">--</span> Hz</div>
                    <div style="margin-top: 10px; opacity: 0.6;">Click/Drag to play</div>
                </div>
            </div>

            <div class="synth-grid">
                <div class="param">
                    <div class="param-label">WAVE TYPE</div>
                    <select class="btn btn-small" id="synth-wave" onchange="STUDIO.updateSynth()">
                        <option value="sine">SINE</option>
                        <option value="square">SQUARE</option>
                        <option value="sawtooth">SAWTOOTH</option>
                        <option value="triangle">TRIANGLE</option>
                    </select>
                </div>
                
                <div class="param">
                    <div class="param-label">LFO RATE</div>
                    <input type="range" id="lfo-rate" min="0" max="20" value="0" step="0.5" oninput="STUDIO.updateSynth()">
                    <div class="param-value" id="lfo-rate-val">0 Hz</div>
                </div>
                
                <div class="param">
                    <div class="param-label">LFO DEPTH</div>
                    <input type="range" id="lfo-depth" min="0" max="1000" value="0" oninput="STUDIO.updateSynth()">
                    <div class="param-value" id="lfo-depth-val">0</div>
                </div>
                
                <div class="param">
                    <div class="param-label">DISTORTION</div>
                    <input type="range" id="distortion" min="0" max="100" value="0" oninput="STUDIO.updateSynth()">
                    <div class="param-value" id="distortion-val">0%</div>
                </div>
                
                <div class="param">
                    <div class="param-label">DELAY TIME</div>
                    <input type="range" id="delay-time" min="0" max="1000" value="250" oninput="STUDIO.updateSynth()">
                    <div class="param-value" id="delay-time-val">250ms</div>
                </div>
                
                <div class="param">
                    <div class="param-label">DELAY FEEDBACK</div>
                    <input type="range" id="delay-feedback" min="0" max="90" value="30" oninput="STUDIO.updateSynth()">
                    <div class="param-value" id="delay-fb-val">30%</div>
                </div>
                
                <div class="param">
                    <div class="param-label">REVERB</div>
                    <input type="range" id="synth-reverb" min="0" max="100" value="30" oninput="STUDIO.updateSynth()">
                    <div class="param-value" id="synth-reverb-val">30%</div>
                </div>
                
                <div class="param">
                    <div class="param-label">ATTACK</div>
                    <input type="range" id="synth-attack" min="0" max="1000" value="50" oninput="STUDIO.updateSynth()">
                    <div class="param-value" id="synth-attack-val">50ms</div>
                </div>
            </div>
        </div>

        <!-- LIVE CODING -->
        <div class="section">
            <div class="section-title">Live Coding</div>
            <div class="section-subtitle">Control tempo with bpm() | Use beat() for musical timing | Enable loop mode for continuous playback</div>
            
            <div class="controls">
                <button class="btn" onclick="STUDIO.executeCode()">RUN CODE (Ctrl+Enter)</button>
                <button class="btn" id="loop-btn" onclick="STUDIO.toggleCodeLoop()">LOOP: OFF</button>
                <button class="btn" onclick="STUDIO.stopCode()">STOP</button>
                <button class="btn" onclick="STUDIO.clearCode()">CLEAR</button>
                <button class="btn" onclick="STUDIO.loadExample()">LOAD EXAMPLE</button>
            </div>
            
            <div class="code-editor">
                <textarea class="code-input" id="code-input" placeholder="// Set tempo:
bpm(140)

// DRUMS: kick, snare, hihat, perc

// SYNTHS: bass, lead, pad, pluck, stab
synth('bass', 60)  // MIDI note 60 (C3)
beat(1)
synth('lead', 72)  // MIDI note 72 (C4)

// EFFECTS:
play('kick')
beat(0.5)
synth('stab', 64)
beat(0.5)

// Press Ctrl+Enter or enable LOOP"></textarea>

// Set tempo
tempo(128)

// Euclidean rhythms (steps, pulses)
const kick = euclidean(16, 4)
loop(16, (i) => {
  if (kick[i]) play('kick')
  beat(0.25)
})

// Probability (70% chance)
loop(8, () => {
  prob(0.7, () => play('hihat'))
  beat(0.5)
})

// Generative melody
loop(4, () => {
  const note = walk('Am', 'minor', 2)
  synth('bass', note)
  beat(1)
})

// Random from array
loop(4, () => {
  synth('lead', choose([60, 64, 67, 72]))
  beat(0.5)
})

// Pattern language
pattern('[bd sd] hh*2 bd cp')

// Press Ctrl+Enter or enable LOOP!"></textarea>
bpm(140)

// DRUMS: kick, snare, hihat, perc, clap, rim

// SYNTHS: bass, lead, pad, pluck, stab
synth('bass', 60)  // MIDI note 60 (C3)
beat(1)
synth('lead', 72)  // MIDI note 72 (C4)

// EFFECTS:
play('kick')
beat(0.5)
synth('stab', 64)
beat(0.5)

// Press Ctrl+Enter or enable LOOP"></textarea>
            </div>
            
            <div class="controls">
                <button class="btn" onclick="STUDIO.executeCode()">RUN CODE (Ctrl+Enter)</button>
                <button class="btn" id="loop-btn" onclick="STUDIO.toggleCodeLoop()">LOOP: OFF</button>
                <button class="btn" onclick="STUDIO.stopCode()">STOP</button>
                <button class="btn" onclick="STUDIO.clearCode()">CLEAR</button>
                <button class="btn" onclick="STUDIO.loadExample()">LOAD EXAMPLE</button>
            </div>
            
            <div class="code-output" id="code-output">> Ready to execute code...</div>
        </div>

        <!-- MIDI CONTROLLER -->
        <div class="section" style="border: 2px solid var(--accent);">
            <div class="section-title" style="color: var(--accent);">MIDI CONTROLLER</div>
            <div class="section-subtitle">Connect MIDI keyboards, controllers, and drum pads</div>
            
            <!-- Connection Controls -->
            <div style="background: #0a0a0a; padding: 20px; margin-bottom: 20px; border-left: 3px solid var(--accent);">
                <div style="font-family: 'Bebas Neue'; font-size: 16px; letter-spacing: 2px; margin-bottom: 15px; color: var(--accent);">DEVICE CONNECTION</div>
                
                <div style="display: grid; grid-template-columns: auto 1fr auto auto; gap: 15px; align-items: center; margin-bottom: 15px;">
                    <button class="btn" onclick="STUDIO.detectMIDI()" style="min-width: 150px;">DETECT DEVICES</button>
                    <select class="btn" id="midi-device-select" disabled style="flex: 1;">
                        <option value="">Click Detect Devices first</option>
                    </select>
                    <button class="btn" id="midi-connect-btn" onclick="STUDIO.connectSelectedMIDI()" disabled style="min-width: 120px;">CONNECT</button>
                    <span id="midi-status" style="color: #666; font-family: 'JetBrains Mono'; font-size: 12px;">Not connected</span>
                </div>
                
                <div style="padding: 10px; background: #000; border-left: 2px solid #666; font-family: 'JetBrains Mono'; font-size: 11px; color: #666;">
                    <div style="color: var(--accent); margin-bottom: 5px;">STATUS:</div>
                    <div id="midi-info">No MIDI device connected</div>
                </div>
            </div>

            <!-- MIDI Routing -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">
                
                <div style="background: #0a0a0a; padding: 15px; border-left: 3px solid var(--accent);">
                    <div style="font-family: 'Bebas Neue'; font-size: 14px; margin-bottom: 10px; color: var(--accent);">ROUTE TO</div>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="radio" name="midi-target" value="drums" checked onchange="STUDIO.setMIDITarget(this.value)">
                            <span>DRUM MACHINE</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="radio" name="midi-target" value="bass" onchange="STUDIO.setMIDITarget(this.value)">
                            <span>BASSLINE</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="radio" name="midi-target" value="synth" onchange="STUDIO.setMIDITarget(this.value)">
                            <span>CURSOR SYNTH</span>
                        </label>
                    </div>
                </div>

                <div style="background: #0a0a0a; padding: 15px; border-left: 3px solid var(--accent);">
                    <div style="font-family: 'Bebas Neue'; font-size: 14px; margin-bottom: 10px; color: var(--accent);">MIDI LEARN</div>
                    <button class="btn" onclick="STUDIO.enableMIDILearn()" style="width: 100%; margin-bottom: 8px;">ENABLE LEARN MODE</button>
                    <div style="font-size: 11px; color: #666; line-height: 1.4;">
                        Click parameter, move MIDI control to map
                    </div>
                </div>

                <div style="background: #0a0a0a; padding: 15px; border-left: 3px solid var(--accent);">
                    <div style="font-family: 'Bebas Neue'; font-size: 14px; margin-bottom: 10px; color: var(--accent);">ACTIVITY</div>
                    <div id="midi-activity" style="font-family: 'JetBrains Mono'; font-size: 11px; color: #666; min-height: 60px;">
                        Waiting for MIDI input...
                    </div>
                </div>

            </div>

            <div class="info-box">
                <strong>DRUM MACHINE:</strong> Keys play drum tracks (1=Kick, 2=Snare, 3=Hihat, 4=Perc) | 
                <strong>BASSLINE:</strong> Keys add notes to sequence | 
                <strong>CURSOR SYNTH:</strong> Keys play synth directly | 
                <strong>MIDI LEARN:</strong> Map knobs/faders to any parameter
            </div>
        </div>
    </div>

    <div class="footer">
        <div>DRIS STUDIO ¬© 2025</div>
        <div class="social-links">
            <a href="#">SOUNDCLOUD</a>
            <a href="#">INSTAGRAM</a>
            <a href="#">YOUTUBE</a>
            <a href="#">CONTACT</a>
        </div>
    </div>

        </div>
    </div>

    <script>
        const STUDIO = (() => {
            let audioCtx;
            
            // DRUM MACHINE
            let drumPlaying = false;
            let drumStep = 0;
            let drumTempo = 120;
            let drumTimeout;
            let drumKit = '909';
            let humanize = 0;
            let drumSequence = [
                [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
                [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
                [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
                [0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0]
            ];
            let drumProbability = [
                Array(16).fill(100),
                Array(16).fill(100),
                Array(16).fill(100),
                Array(16).fill(100)
            ];
            const drumTrackNames = ['KICK', 'SNARE', 'HIHAT', 'PERC'];
            
            // AI IMAGE/VIDEO GENERATOR
            let aiCanvas = null;
            let aiCtx = null;
            let aiImage = null;
            let aiVideoFrames = [];
            let aiIsGenerating = false;
            let aiIsRecording = false;
            let aiRecordedChunks = [];
            
            // Musical scales for bassline generation
            const scales = {
                minor: [0, 2, 3, 5, 7, 8, 10],
                major: [0, 2, 4, 5, 7, 9, 11],
                phrygian: [0, 1, 3, 5, 7, 8, 10],
                dorian: [0, 2, 3, 5, 7, 9, 10]
            };
            
            // BASSLINE
            let bassPlaying = false;
            let bassStep = 0;
            let bassTimeout;
            let bassWave = 'sawtooth';
            let bassSequence = Array(16).fill().map(() => ({ active: 0, note: 0 })); // note: 0-11 (C to B)
            let bassRecording = false;
            let bassRecorder = null;
            let bassRecordingChunks = [];
            
            // Bass Filter parameters
            let bassFilterType = 'lowpass';
            let bassFilterCutoff = 2000;
            let bassFilterResonance = 1;
            let bassFilterEnvelope = 0;
            
            const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            
            // SYNTH
            let synthOsc = null;
            let synthGain = null;
            let synthFilter = null;
            let synthLFO = null;
            let synthLFOGain = null;
            let synthDelay = null;
            let synthFeedback = null;
            let synthReverb = null;
            let synthDistortion = null;
            
            // VISUAL
            let visualCanvas, visualCtx;
            let isReactive = false;
            let analyser = null;
            let dataArray = null;
            let visualMode = 0; // 0=spectrum, 1=particles, 2=radial, 3=waveform, 4=tunnel, 5=nebula
            let visualModes = ['SPECTRUM', 'PARTICLES', 'RADIAL', 'WAVEFORM', 'TUNNEL', 'NEBULA'];
            let particles = [];
            let tunnelRotation = 0;
            let nebulaPoints = [];
            let colorScheme = { hue: 120, saturation: 70 };
            let visualIntensity = 50;
            let visualSpeed = 5;
            
            // === VISUAL REACTOR ===
            function setupVisualCanvas() {
                visualCanvas = document.getElementById('visual-canvas');
                visualCtx = visualCanvas.getContext('2d');
                visualCanvas.width = visualCanvas.offsetWidth;
                visualCanvas.height = visualCanvas.offsetHeight;
                
                // Initialize particles
                for (let i = 0; i < 100; i++) {
                    particles.push({
                        x: Math.random() * visualCanvas.width,
                        y: Math.random() * visualCanvas.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        size: Math.random() * 3 + 1,
                        energy: 0
                    });
                }
                
                // Initialize nebula
                for (let i = 0; i < 200; i++) {
                    nebulaPoints.push({
                        x: Math.random() * visualCanvas.width,
                        y: Math.random() * visualCanvas.height,
                        z: Math.random() * 1000,
                        size: Math.random() * 4 + 1
                    });
                }
                
                animateVisual();
            }
            
            function animateVisual() {
                const w = visualCanvas.width;
                const h = visualCanvas.height;
                
                if (isReactive && analyser) {
                    analyser.getByteFrequencyData(dataArray);
                    
                    // Get audio features
                    const bass = getAverageFrequency(0, 5);
                    const mid = getAverageFrequency(5, 20);
                    const treble = getAverageFrequency(20, 40);
                    
                    visualCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    visualCtx.fillRect(0, 0, w, h);
                    
                    switch(visualMode) {
                        case 0: // SPECTRUM BARS
                            drawSpectrum(bass, mid, treble);
                            break;
                        case 1: // PARTICLES
                            drawParticles(bass, mid, treble);
                            break;
                        case 2: // RADIAL
                            drawRadial(bass, mid, treble);
                            break;
                        case 3: // WAVEFORM
                            drawWaveform();
                            break;
                        case 4: // TUNNEL
                            drawTunnel(bass, mid, treble);
                            break;
                        case 5: // NEBULA
                            drawNebula(bass, mid, treble);
                            break;
                    }
                } else {
                    // Ambient mode
                    visualCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    visualCtx.fillRect(0, 0, w, h);
                    
                    for (let i = 0; i < 3; i++) {
                        visualCtx.beginPath();
                        visualCtx.arc(
                            Math.random() * w,
                            Math.random() * h,
                            Math.random() * 30 + 5,
                            0,
                            Math.PI * 2
                        );
                        visualCtx.fillStyle = `hsla(${colorScheme.hue + Math.random() * 60}, ${colorScheme.saturation}%, 50%, 0.1)`;
                        visualCtx.fill();
                    }
                }
                
                requestAnimationFrame(animateVisual);
            }
            
            function getAverageFrequency(start, end) {
                let sum = 0;
                for (let i = start; i < end && i < dataArray.length; i++) {
                    sum += dataArray[i];
                }
                return (sum / (end - start)) / 255;
            }
            
            // SPECTRUM BARS
            function drawSpectrum(bass, mid, treble) {
                const barWidth = visualCanvas.width / dataArray.length;
                const intensity = visualIntensity / 50;
                
                for (let i = 0; i < dataArray.length; i++) {
                    const barHeight = (dataArray[i] / 255) * visualCanvas.height * intensity;
                    const hue = (colorScheme.hue + (i / dataArray.length) * 120) % 360;
                    
                    // Gradient bars
                    const gradient = visualCtx.createLinearGradient(
                        i * barWidth,
                        visualCanvas.height - barHeight,
                        i * barWidth,
                        visualCanvas.height
                    );
                    gradient.addColorStop(0, `hsla(${hue}, ${colorScheme.saturation}%, 60%, 0.9)`);
                    gradient.addColorStop(1, `hsla(${hue}, ${colorScheme.saturation}%, 40%, 0.6)`);
                    
                    visualCtx.fillStyle = gradient;
                    visualCtx.fillRect(
                        i * barWidth,
                        visualCanvas.height - barHeight,
                        barWidth - 2,
                        barHeight
                    );
                }
            }
            
            // PARTICLES
            function drawParticles(bass, mid, treble) {
                particles.forEach(p => {
                    // React to audio
                    p.energy = p.energy * 0.9 + (bass + mid) * 0.5;
                    
                    // Movement
                    p.vx += (Math.random() - 0.5) * 0.5;
                    p.vy += (Math.random() - 0.5) * 0.5;
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    
                    p.x += p.vx * (visualSpeed / 5);
                    p.y += p.vy * (visualSpeed / 5);
                    
                    // Wrap around
                    if (p.x < 0) p.x = visualCanvas.width;
                    if (p.x > visualCanvas.width) p.x = 0;
                    if (p.y < 0) p.y = visualCanvas.height;
                    if (p.y > visualCanvas.height) p.y = 0;
                    
                    // Draw
                    const size = p.size * (1 + p.energy * (visualIntensity / 50));
                    visualCtx.beginPath();
                    visualCtx.arc(p.x, p.y, size, 0, Math.PI * 2);
                    visualCtx.fillStyle = `hsla(${colorScheme.hue}, ${colorScheme.saturation}%, ${50 + p.energy * 30}%, ${0.6 + p.energy * 0.4})`;
                    visualCtx.fill();
                    
                    // Connections
                    particles.forEach(p2 => {
                        const dx = p.x - p2.x;
                        const dy = p.y - p2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 100 * (p.energy + 0.5)) {
                            visualCtx.beginPath();
                            visualCtx.moveTo(p.x, p.y);
                            visualCtx.lineTo(p2.x, p2.y);
                            visualCtx.strokeStyle = `hsla(${colorScheme.hue}, ${colorScheme.saturation}%, 50%, ${0.1 * (1 - dist / 100)})`;
                            visualCtx.lineWidth = 1;
                            visualCtx.stroke();
                        }
                    });
                });
            }
            
            // RADIAL
            function drawRadial(bass, mid, treble) {
                const centerX = visualCanvas.width / 2;
                const centerY = visualCanvas.height / 2;
                const intensity = visualIntensity / 50;
                
                for (let i = 0; i < dataArray.length; i++) {
                    const angle = (i / dataArray.length) * Math.PI * 2;
                    const radius = (dataArray[i] / 255) * 200 * intensity;
                    
                    const x1 = centerX + Math.cos(angle) * 50;
                    const y1 = centerY + Math.sin(angle) * 50;
                    const x2 = centerX + Math.cos(angle) * (50 + radius);
                    const y2 = centerY + Math.sin(angle) * (50 + radius);
                    
                    const hue = (colorScheme.hue + (i / dataArray.length) * 180) % 360;
                    
                    visualCtx.beginPath();
                    visualCtx.moveTo(x1, y1);
                    visualCtx.lineTo(x2, y2);
                    visualCtx.strokeStyle = `hsla(${hue}, ${colorScheme.saturation}%, 60%, 0.7)`;
                    visualCtx.lineWidth = 3;
                    visualCtx.stroke();
                    
                    // Glow
                    visualCtx.beginPath();
                    visualCtx.arc(x2, y2, 4, 0, Math.PI * 2);
                    visualCtx.fillStyle = `hsla(${hue}, ${colorScheme.saturation}%, 70%, 0.8)`;
                    visualCtx.fill();
                }
            }
            
            // WAVEFORM
            function drawWaveform() {
                const bufferLength = analyser.fftSize;
                const waveData = new Uint8Array(bufferLength);
                analyser.getByteTimeDomainData(waveData);
                
                const sliceWidth = visualCanvas.width / bufferLength;
                let x = 0;
                
                visualCtx.lineWidth = 3;
                visualCtx.strokeStyle = `hsla(${colorScheme.hue}, ${colorScheme.saturation}%, 60%, 0.8)`;
                visualCtx.beginPath();
                
                for (let i = 0; i < bufferLength; i++) {
                    const v = waveData[i] / 128.0;
                    const y = v * visualCanvas.height / 2;
                    
                    if (i === 0) {
                        visualCtx.moveTo(x, y);
                    } else {
                        visualCtx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                visualCtx.stroke();
                
                // Shadow effect
                visualCtx.strokeStyle = `hsla(${colorScheme.hue + 30}, ${colorScheme.saturation}%, 70%, 0.4)`;
                visualCtx.lineWidth = 6;
                visualCtx.stroke();
            }
            
            // TUNNEL
            function drawTunnel(bass, mid, treble) {
                tunnelRotation += 0.02 * (visualSpeed / 5);
                const intensity = visualIntensity / 50;
                
                for (let i = 0; i < 20; i++) {
                    const size = (i + 1) * 30 * (1 + bass * intensity);
                    const rotation = tunnelRotation + i * 0.2;
                    const alpha = 1 - (i / 20);
                    
                    visualCtx.save();
                    visualCtx.translate(visualCanvas.width / 2, visualCanvas.height / 2);
                    visualCtx.rotate(rotation);
                    
                    const hue = (colorScheme.hue + i * 18) % 360;
                    visualCtx.strokeStyle = `hsla(${hue}, ${colorScheme.saturation}%, 60%, ${alpha * 0.6})`;
                    visualCtx.lineWidth = 3;
                    visualCtx.strokeRect(-size, -size, size * 2, size * 2);
                    
                    visualCtx.restore();
                }
            }
            
            // NEBULA
            function drawNebula(bass, mid, treble) {
                const intensity = visualIntensity / 50;
                
                nebulaPoints.forEach(point => {
                    // Z-depth movement
                    point.z -= 2 * (visualSpeed / 5) * (1 + bass * intensity);
                    
                    if (point.z < 1) {
                        point.z = 1000;
                        point.x = Math.random() * visualCanvas.width;
                        point.y = Math.random() * visualCanvas.height;
                    }
                    
                    // 3D projection
                    const scale = 1000 / point.z;
                    const x = (point.x - visualCanvas.width / 2) * scale + visualCanvas.width / 2;
                    const y = (point.y - visualCanvas.height / 2) * scale + visualCanvas.height / 2;
                    const size = point.size * scale * (1 + treble * intensity);
                    
                    if (x >= 0 && x <= visualCanvas.width && y >= 0 && y <= visualCanvas.height) {
                        const hue = (colorScheme.hue + (1000 - point.z) / 3) % 360;
                        const alpha = Math.min(1, scale);
                        
                        visualCtx.beginPath();
                        visualCtx.arc(x, y, size, 0, Math.PI * 2);
                        visualCtx.fillStyle = `hsla(${hue}, ${colorScheme.saturation}%, 60%, ${alpha * 0.8})`;
                        visualCtx.fill();
                        
                        // Glow
                        visualCtx.shadowBlur = 20 * scale;
                        visualCtx.shadowColor = `hsla(${hue}, ${colorScheme.saturation}%, 60%, 0.5)`;
                        visualCtx.fill();
                        visualCtx.shadowBlur = 0;
                    }
                });
            }
            
            function cycleVisualMode() {
                visualMode = (visualMode + 1) % visualModes.length;
                document.getElementById('mode-display').textContent = visualModes[visualMode];
            }
            
            function randomColors() {
                colorScheme.hue = Math.random() * 360;
                colorScheme.saturation = 60 + Math.random() * 30;
            }
            
            function setVisualIntensity(val) {
                visualIntensity = parseFloat(val);
                document.getElementById('intensity-val').textContent = val;
            }
            
            function setVisualSpeed(val) {
                visualSpeed = parseFloat(val);
                document.getElementById('speed-val').textContent = val;
            }
            
            function generateVisual() {
                // Placeholder - no longer used
            }
            
            function randomPrompt() {
                // Placeholder - no longer used
            }
            
            // AUDIO NODES
            let masterGain;
            let masterReverb;
            
            // MIDI
            let midiAccess = null;
            let midiInputs = [];
            let midiTarget = 'drums'; // drums, bass, or synth
            let midiLearnMode = false;
            
            // === MIDI SUPPORT ===
            async function detectMIDI() {
                const statusEl = document.getElementById('midi-status');
                const selectEl = document.getElementById('midi-device-select');
                const connectBtn = document.getElementById('midi-connect-btn');
                const infoEl = document.getElementById('midi-info');
                
                console.log('[MIDI] Detecting devices...');
                
                // Check browser support
                if (!navigator.requestMIDIAccess) {
                    const msg = 'Web MIDI not supported. Use Chrome, Edge, or Opera.';
                    statusEl.textContent = 'Not supported';
                    statusEl.style.color = '#ff0000';
                    infoEl.textContent = msg;
                    console.error('[MIDI]', msg);
                    alert(msg);
                    return;
                }
                
                try {
                    console.log('[MIDI] Requesting MIDI access...');
                    midiAccess = await navigator.requestMIDIAccess();
                    console.log('[MIDI] Access granted');
                    
                    midiInputs = Array.from(midiAccess.inputs.values());
                    console.log('[MIDI] Found', midiInputs.length, 'device(s):', midiInputs.map(i => i.name));
                    
                    if (midiInputs.length === 0) {
                        statusEl.textContent = 'No devices found';
                        statusEl.style.color = '#ff6600';
                        infoEl.textContent = 'No MIDI devices detected. Please connect a MIDI keyboard or controller and try again.';
                        console.warn('[MIDI] No devices found');
                        return;
                    }
                    
                    // Populate dropdown
                    selectEl.innerHTML = '<option value="">Select a device...</option>';
                    midiInputs.forEach((input, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = input.name || `Device ${index + 1}`;
                        selectEl.appendChild(option);
                    });
                    
                    selectEl.disabled = false;
                    connectBtn.disabled = false;
                    statusEl.textContent = `Found ${midiInputs.length} device(s)`;
                    statusEl.style.color = '#00ff85';
                    infoEl.innerHTML = `<div style="color: var(--accent);">‚úì Detected ${midiInputs.length} MIDI device(s)</div><div style="color: #666; margin-top: 5px;">Select one and click Connect</div>`;
                    console.log('[MIDI] Detection successful');
                    
                } catch (error) {
                    const msg = 'MIDI detection failed: ' + error.message;
                    statusEl.textContent = 'Detection failed';
                    statusEl.style.color = '#ff0000';
                    infoEl.textContent = msg;
                    console.error('[MIDI]', error);
                    alert(msg + '\n\nMake sure no other application is using the MIDI device.');
                }
            }
            
            function connectSelectedMIDI() {
                const selectEl = document.getElementById('midi-device-select');
                const statusEl = document.getElementById('midi-status');
                const infoEl = document.getElementById('midi-info');
                const deviceIndex = parseInt(selectEl.value);
                
                if (isNaN(deviceIndex)) {
                    alert('Please select a device first');
                    return;
                }
                
                const input = midiInputs[deviceIndex];
                if (!input) return;
                
                // Disconnect previous inputs
                midiInputs.forEach(inp => inp.onmidimessage = null);
                
                // Connect to selected input
                input.onmidimessage = handleMIDIMessage;
                
                statusEl.textContent = `Connected: ${input.name}`;
                statusEl.style.color = '#00ff85';
                infoEl.innerHTML = `<div style="color: var(--accent);">Connected to: ${input.name}</div><div>Routing to: ${midiTarget.toUpperCase()}</div><div style="margin-top: 5px; color: #666;">Send MIDI notes to play...</div>`;
            }
            
            function setMIDITarget(target) {
                midiTarget = target;
                const infoEl = document.getElementById('midi-info');
                if (midiInputs.length > 0) {
                    const currentInfo = infoEl.innerHTML;
                    if (currentInfo.includes('Connected to:')) {
                        const deviceName = currentInfo.match(/Connected to: (.*?)</)[1];
                        infoEl.innerHTML = `<div style="color: var(--accent);">Connected to: ${deviceName}</div><div>Routing to: ${target.toUpperCase()}</div><div style="margin-top: 5px; color: #666;">Send MIDI notes to play...</div>`;
                    }
                }
            }
            
            function enableMIDILearn() {
                midiLearnMode = !midiLearnMode;
                const btn = event.target;
                if (midiLearnMode) {
                    btn.textContent = 'DISABLE LEARN MODE';
                    btn.classList.add('active');
                    alert('MIDI Learn enabled! Click any knob/slider, then move a MIDI control to map it.');
                } else {
                    btn.textContent = 'ENABLE LEARN MODE';
                    btn.classList.remove('active');
                }
            }
            
            async function connectMIDI() {
                // Legacy function - now just calls detectMIDI
                await detectMIDI();
            }
            
            function handleMIDIMessage(message) {
                const [command, note, velocity] = message.data;
                const noteOn = (command & 0xf0) === 0x90;
                const noteOff = (command & 0xf0) === 0x80;
                const controlChange = (command & 0xf0) === 0xb0;
                
                // Display activity
                const activityEl = document.getElementById('midi-activity');
                if (activityEl) {
                    if (noteOn && velocity > 0) {
                        activityEl.innerHTML = `<div style="color: var(--accent);">NOTE ON: ${note} (vel: ${velocity})</div><div style="color: #666;">Target: ${midiTarget.toUpperCase()}</div>`;
                    } else if (controlChange) {
                        activityEl.innerHTML = `<div style="color: var(--accent);">CC: ${note} = ${velocity}</div><div style="color: #666;">MIDI Learn: ${midiLearnMode ? 'ACTIVE' : 'OFF'}</div>`;
                    }
                }
                
                if (noteOn && velocity > 0) {
                    // Route based on target
                    switch(midiTarget) {
                        case 'drums':
                            // Map MIDI notes to drum tracks
                            const drumMap = {
                                36: 0, // C2 -> Kick
                                38: 1, // D2 -> Snare  
                                42: 2, // F#2 -> Hihat
                                43: 3, // G2 -> Perc
                            };
                            const track = drumMap[note];
                            if (track !== undefined) {
                                playDrumSound(track, drumKit);
                            }
                            break;
                            
                        case 'bass':
                            // Play bass synth
                            const freq = 440 * Math.pow(2, (note - 69) / 12);
                            const now = audioCtx.currentTime;
                            const osc = audioCtx.createOscillator();
                            osc.type = bassWave;
                            osc.frequency.value = freq;
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(velocity / 127 * 0.6, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                            osc.connect(gain);
                            gain.connect(audioCtx.destination);
                            osc.start(now);
                            osc.stop(now + 0.4);
                            break;
                            
                        case 'synth':
                            // Play cursor synth
                            playSynthNote(note, velocity / 127);
                            break;
                    }
                }
            }
            
            // === INIT ===
            function init() {
                try {
                    console.log('Initializing STUDIO...');
                    
                    // Create audio context
                    try {
                        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                        console.log('Audio context created');
                    } catch (audioErr) {
                        console.error('Failed to create audio context:', audioErr);
                        throw new Error('Audio not supported in this browser');
                    }
                    
                    // Setup audio
                    try {
                        setupAudio();
                        console.log('Audio setup complete');
                    } catch (audioErr) {
                        console.error('Audio setup failed:', audioErr);
                    }
                    
                    // Build sequencers
                    try {
                        buildDrumSequencer();
                        console.log('Drum sequencer built');
                    } catch (drumErr) {
                        console.error('Drum sequencer failed:', drumErr);
                    }
                    
                    try {
                        buildBassSequencer();
                        console.log('Bass sequencer built');
                    } catch (bassErr) {
                        console.error('Bass sequencer failed:', bassErr);
                    }
                    
                    // Setup canvases
                    try {
                        setupSynthCanvas();
                        console.log('Synth canvas setup');
                    } catch (synthErr) {
                        console.error('Synth canvas failed:', synthErr);
                    }
                    
                    try {
                        setupVisualCanvas();
                        console.log('Visual canvas setup');
                    } catch (visualErr) {
                        console.error('Visual canvas failed:', visualErr);
                    }
                    
                    // Setup keyboard
                    try {
                        setupKeyboardShortcuts();
                        console.log('Keyboard shortcuts setup');
                    } catch (keyErr) {
                        console.error('Keyboard setup failed:', keyErr);
                    }
                    
                    console.log('STUDIO initialization complete');
                } catch (err) {
                    console.error('CRITICAL: STUDIO init failed:', err);
                    throw err;
                }
            }
            
            function setupAudio() {
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0.8;
                masterGain.connect(audioCtx.destination);
                
                // Master reverb
                const reverbLength = audioCtx.sampleRate * 2;
                const impulse = audioCtx.createBuffer(2, reverbLength, audioCtx.sampleRate);
                for (let ch = 0; ch < 2; ch++) {
                    const data = impulse.getChannelData(ch);
                    for (let i = 0; i < reverbLength; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / reverbLength, 2);
                    }
                }
                masterReverb = audioCtx.createConvolver();
                masterReverb.buffer = impulse;
                masterReverb.connect(masterGain);
                
                // Analyser for visuals
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                masterGain.connect(analyser);
            }
            
            // === DRUM MACHINE ===
            function buildDrumSequencer() {
                const container = document.getElementById('drum-sequencer');
                container.innerHTML = '';
                
                for (let track = 0; track < 4; track++) {
                    const trackDiv = document.createElement('div');
                    trackDiv.className = 'track';
                    
                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'track-name';
                    nameDiv.textContent = drumTrackNames[track];
                    trackDiv.appendChild(nameDiv);
                    
                    for (let step = 0; step < 16; step++) {
                        const stepDiv = document.createElement('div');
                        stepDiv.className = 'step';
                        if ((step + 1) % 4 === 0 && step < 15) stepDiv.classList.add('beat-4');
                        if (drumSequence[track][step]) stepDiv.classList.add('active');
                        
                        stepDiv.onclick = () => {
                            drumSequence[track][step] = drumSequence[track][step] ? 0 : 1;
                            stepDiv.classList.toggle('active');
                        };
                        
                        trackDiv.appendChild(stepDiv);
                    }
                    
                    container.appendChild(trackDiv);
                }
            }
            
            function toggleDrums() {
                drumPlaying = !drumPlaying;
                const btn = document.getElementById('drum-play');
                
                if (drumPlaying) {
                    btn.textContent = 'STOP';
                    btn.classList.add('active');
                    drumStep = 0;
                    drumLoop();
                } else {
                    btn.textContent = 'PLAY';
                    btn.classList.remove('active');
                    clearTimeout(drumTimeout);
                    clearDrumIndicators();
                }
            }
            
            function drumLoop() {
                if (!drumPlaying) return;
                
                clearDrumIndicators();
                
                for (let track = 0; track < 4; track++) {
                    if (drumSequence[track][drumStep]) {
                        playDrumSound(track, drumKit);
                        
                        const tracks = document.querySelectorAll('#drum-sequencer .track');
                        tracks[track].children[drumStep + 1].classList.add('playing');
                    }
                }
                
                drumStep = (drumStep + 1) % 16;
                const stepTime = (60 / drumTempo) / 4 * 1000;
                drumTimeout = setTimeout(drumLoop, stepTime);
            }
            
            function clearDrumIndicators() {
                document.querySelectorAll('#drum-sequencer .step.playing').forEach(el => {
                    el.classList.remove('playing');
                });
            }
            
            function playDrumSound(track, kit) {
                const now = audioCtx.currentTime;
                const kits = {
                    '909': [
                        () => { // Kick
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            osc.frequency.setValueAtTime(150, now);
                            osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.5);
                            gain.gain.setValueAtTime(1, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(now);
                            osc.stop(now + 0.5);
                        },
                        () => { // Snare
                            const noise = createNoise(0.2);
                            const filter = audioCtx.createBiquadFilter();
                            filter.type = 'highpass';
                            filter.frequency.value = 1000;
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(1, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                            noise.connect(filter).connect(gain).connect(audioCtx.destination);
                            noise.start(now);
                            noise.stop(now + 0.2);
                        },
                        () => { // Hihat
                            const noise = createNoise(0.05);
                            const filter = audioCtx.createBiquadFilter();
                            filter.type = 'highpass';
                            filter.frequency.value = 7000;
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.5, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                            noise.connect(filter).connect(gain).connect(audioCtx.destination);
                            noise.start(now);
                            noise.stop(now + 0.05);
                        },
                        () => { // Perc
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            osc.frequency.setValueAtTime(800, now);
                            osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                            gain.gain.setValueAtTime(0.3, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(now);
                            osc.stop(now + 0.1);
                        }
                    ],
                    '808': [
                        () => { // Deep Kick
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            osc.frequency.setValueAtTime(120, now);
                            osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.8);
                            gain.gain.setValueAtTime(1.2, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(now);
                            osc.stop(now + 0.8);
                        },
                        () => kits['909'][1](),
                        () => kits['909'][2](),
                        () => kits['909'][3]()
                    ],
                    'trap': [
                        () => { // Sub kick
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            osc.frequency.setValueAtTime(60, now);
                            osc.frequency.exponentialRampToValueAtTime(30, now + 1);
                            gain.gain.setValueAtTime(1.5, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 1);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(now);
                            osc.stop(now + 1);
                        },
                        () => { // Clap
                            const noise = createNoise(0.1);
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.8, now);
                            gain.gain.setValueAtTime(0, now + 0.02);
                            gain.gain.setValueAtTime(0.7, now + 0.04);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                            noise.connect(gain).connect(audioCtx.destination);
                            noise.start(now);
                            noise.stop(now + 0.1);
                        },
                        () => kits['909'][2](),
                        () => { // 808 rim
                            const osc = audioCtx.createOscillator();
                            osc.type = 'square';
                            osc.frequency.value = 400;
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.2, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(now);
                            osc.stop(now + 0.08);
                        }
                    ],
                    'lofi': [
                        () => { // Soft kick
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            osc.frequency.setValueAtTime(80, now);
                            osc.frequency.exponentialRampToValueAtTime(40, now + 0.3);
                            gain.gain.setValueAtTime(0.6, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                            osc.connect(gain).connect(masterReverb);
                            osc.start(now);
                            osc.stop(now + 0.3);
                        },
                        () => { // Brush snare
                            const noise = createNoise(0.15);
                            const filter = audioCtx.createBiquadFilter();
                            filter.type = 'bandpass';
                            filter.frequency.value = 1500;
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.4, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                            noise.connect(filter).connect(gain).connect(masterReverb);
                            noise.start(now);
                            noise.stop(now + 0.15);
                        },
                        () => kits['909'][2](),
                        () => { // Vinyl crackle
                            const noise = createNoise(0.05);
                            const filter = audioCtx.createBiquadFilter();
                            filter.type = 'highpass';
                            filter.frequency.value = 3000;
                            const gain = audioCtx.createGain();
                            gain.gain.value = 0.1;
                            noise.connect(filter).connect(gain).connect(audioCtx.destination);
                            noise.start(now);
                            noise.stop(now + 0.05);
                        }
                    ],
                    'cartoon': [
                        () => { // Boing
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            osc.frequency.setValueAtTime(300, now);
                            osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                            gain.gain.setValueAtTime(0.7, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(now);
                            osc.stop(now + 0.3);
                        },
                        () => { // Zap
                            const osc = audioCtx.createOscillator();
                            osc.type = 'sawtooth';
                            osc.frequency.setValueAtTime(1200, now);
                            osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.5, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(now);
                            osc.stop(now + 0.15);
                        },
                        () => { // Pop
                            const osc = audioCtx.createOscillator();
                            osc.frequency.value = 3000;
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.4, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.02);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(now);
                            osc.stop(now + 0.02);
                        },
                        () => { // Blip
                            const osc = audioCtx.createOscillator();
                            osc.type = 'square';
                            osc.frequency.setValueAtTime(600, now);
                            osc.frequency.setValueAtTime(800, now + 0.03);
                            osc.frequency.setValueAtTime(400, now + 0.06);
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.3, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(now);
                            osc.stop(now + 0.1);
                        }
                    ],
                    'industrial': [
                        () => { // Metal hit
                            const noise = createNoise(0.2);
                            const filter = audioCtx.createBiquadFilter();
                            filter.type = 'bandpass';
                            filter.frequency.value = 200;
                            filter.Q.value = 10;
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(1, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                            noise.connect(filter).connect(gain).connect(audioCtx.destination);
                            noise.start(now);
                            noise.stop(now + 0.2);
                        },
                        () => { // Clang
                            const noise = createNoise(0.3);
                            const filter = audioCtx.createBiquadFilter();
                            filter.type = 'highpass';
                            filter.frequency.value = 2000;
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.8, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                            noise.connect(filter).connect(gain).connect(audioCtx.destination);
                            noise.start(now);
                            noise.stop(now + 0.3);
                        },
                        () => { // Static
                            const noise = createNoise(0.04);
                            const gain = audioCtx.createGain();
                            gain.gain.value = 0.4;
                            noise.connect(gain).connect(audioCtx.destination);
                            noise.start(now);
                            noise.stop(now + 0.04);
                        },
                        () => { // Mechanical
                            const osc = audioCtx.createOscillator();
                            osc.type = 'square';
                            osc.frequency.value = 150;
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.3, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(now);
                            osc.stop(now + 0.1);
                        }
                    ],
                    'glitch': [
                        () => { // Bitcrushed kick
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            const shaper = audioCtx.createWaveShaper();
                            
                            // Bitcrush effect
                            const curve = new Float32Array(256);
                            for (let i = 0; i < 256; i++) {
                                curve[i] = Math.floor((i / 256) * 8) / 8;
                            }
                            shaper.curve = curve;
                            
                            osc.frequency.setValueAtTime(180 + Math.random() * 40, now);
                            osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.3);
                            gain.gain.setValueAtTime(0.9, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                            
                            osc.connect(shaper).connect(gain).connect(audioCtx.destination);
                            osc.start(now);
                            osc.stop(now + 0.3);
                        },
                        () => { // Stuttering snare
                            for (let i = 0; i < 3; i++) {
                                const noise = createNoise(0.05);
                                const filter = audioCtx.createBiquadFilter();
                                filter.type = 'bandpass';
                                filter.frequency.value = 1200 + Math.random() * 800;
                                filter.Q.value = 15;
                                const gain = audioCtx.createGain();
                                gain.gain.setValueAtTime(0.6, now + i * 0.02);
                                gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.02 + 0.05);
                                noise.connect(filter).connect(gain).connect(audioCtx.destination);
                                noise.start(now + i * 0.02);
                                noise.stop(now + i * 0.02 + 0.05);
                            }
                        },
                        () => { // Metallic hihat
                            const noise = createNoise(0.03);
                            const filter1 = audioCtx.createBiquadFilter();
                            filter1.type = 'highpass';
                            filter1.frequency.value = 8000;
                            filter1.Q.value = 20;
                            const filter2 = audioCtx.createBiquadFilter();
                            filter2.type = 'bandpass';
                            filter2.frequency.value = 12000;
                            filter2.Q.value = 30;
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.4, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
                            noise.connect(filter1).connect(filter2).connect(gain).connect(audioCtx.destination);
                            noise.start(now);
                            noise.stop(now + 0.03);
                        },
                        () => { // Digital glitch
                            const osc = audioCtx.createOscillator();
                            osc.type = 'square';
                            osc.frequency.setValueAtTime(2000 + Math.random() * 3000, now);
                            osc.frequency.exponentialRampToValueAtTime(100, now + 0.02);
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.2, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.02);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(now);
                            osc.stop(now + 0.02);
                        }
                    ],
                    'broken': [
                        () => { // Lo-fi kick with crackle
                            const osc = audioCtx.createOscillator();
                            const noise = createNoise(0.1);
                            const gain1 = audioCtx.createGain();
                            const gain2 = audioCtx.createGain();
                            
                            // Detuned kick
                            osc.frequency.setValueAtTime(90 + Math.random() * 20, now);
                            osc.frequency.exponentialRampToValueAtTime(30, now + 0.4);
                            gain1.gain.setValueAtTime(0.7, now);
                            gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                            
                            // Vinyl crackle
                            gain2.gain.setValueAtTime(0.1, now);
                            gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                            
                            osc.connect(gain1).connect(audioCtx.destination);
                            noise.connect(gain2).connect(audioCtx.destination);
                            osc.start(now);
                            noise.start(now);
                            osc.stop(now + 0.4);
                            noise.stop(now + 0.1);
                        },
                        () => { // Asymmetric snare
                            const noise = createNoise(0.15);
                            const osc = audioCtx.createOscillator();
                            osc.frequency.value = 200;
                            const filter = audioCtx.createBiquadFilter();
                            filter.type = 'bandpass';
                            filter.frequency.value = 800 + Math.random() * 400;
                            filter.Q.value = 5;
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.8, now);
                            gain.gain.setValueAtTime(0.3, now + 0.05);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                            noise.connect(filter).connect(gain).connect(audioCtx.destination);
                            osc.connect(gain);
                            noise.start(now);
                            osc.start(now);
                            noise.stop(now + 0.15);
                            osc.stop(now + 0.05);
                        },
                        () => { // Broken hihat
                            const noise = createNoise(0.08);
                            const filter = audioCtx.createBiquadFilter();
                            filter.type = 'highpass';
                            filter.frequency.setValueAtTime(6000 + Math.random() * 2000, now);
                            filter.frequency.exponentialRampToValueAtTime(3000, now + 0.08);
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.3 + Math.random() * 0.2, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                            noise.connect(filter).connect(gain).connect(audioCtx.destination);
                            noise.start(now);
                            noise.stop(now + 0.08);
                        },
                        () => { // Warped perc
                            const osc = audioCtx.createOscillator();
                            osc.type = 'triangle';
                            osc.frequency.setValueAtTime(600 + Math.random() * 400, now);
                            osc.frequency.exponentialRampToValueAtTime(50, now + 0.12);
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.25, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(now);
                            osc.stop(now + 0.12);
                        }
                    ],
                    'aphex': [
                        () => { // Resonant filter kick (SAW style)
                            const osc = audioCtx.createOscillator();
                            const filter = audioCtx.createBiquadFilter();
                            filter.type = 'lowpass';
                            filter.frequency.setValueAtTime(800, now);
                            filter.frequency.exponentialRampToValueAtTime(40, now + 0.5);
                            filter.Q.value = 25;
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.8, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                            osc.frequency.setValueAtTime(140, now);
                            osc.frequency.exponentialRampToValueAtTime(35, now + 0.5);
                            osc.connect(filter).connect(gain).connect(audioCtx.destination);
                            osc.start(now);
                            osc.stop(now + 0.5);
                        },
                        () => { // Reverse snare tail
                            const noise = createNoise(0.2);
                            const filter = audioCtx.createBiquadFilter();
                            filter.type = 'highpass';
                            filter.frequency.value = 1500;
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.01, now);
                            gain.gain.exponentialRampToValueAtTime(0.9, now + 0.1);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                            noise.connect(filter).connect(gain).connect(audioCtx.destination);
                            noise.start(now);
                            noise.stop(now + 0.2);
                        },
                        () => { // Detuned FM hihat
                            const carrier = audioCtx.createOscillator();
                            const modulator = audioCtx.createOscillator();
                            const modGain = audioCtx.createGain();
                            carrier.frequency.value = 8000 + Math.random() * 2000;
                            modulator.frequency.value = 3000 + Math.random() * 1000;
                            modGain.gain.value = 500;
                            const gain = audioCtx.createGain();
                            gain.gain.setValueAtTime(0.3, now);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.04);
                            modulator.connect(modGain).connect(carrier.frequency);
                            carrier.connect(gain).connect(audioCtx.destination);
                            carrier.start(now);
                            modulator.start(now);
                            carrier.stop(now + 0.04);
                            modulator.stop(now + 0.04);
                        },
                        () => { // Glitchy stutter perc
                            for (let i = 0; i < 5; i++) {
                                const osc = audioCtx.createOscillator();
                                osc.type = 'square';
                                osc.frequency.value = 1000 + Math.random() * 2000;
                                const gain = audioCtx.createGain();
                                gain.gain.setValueAtTime(0.15, now + i * 0.015);
                                gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.015 + 0.01);
                                osc.connect(gain).connect(audioCtx.destination);
                                osc.start(now + i * 0.015);
                                osc.stop(now + i * 0.015 + 0.01);
                            }
                        }
                    ]
                };
                
                kits[kit][track]();
            }
            
            function createNoise(duration) {
                const bufferSize = audioCtx.sampleRate * duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                return noise;
            }
            
            function setDrumKit(kit) {
                drumKit = kit;
            }
            
            function setDrumTempo(val) {
                drumTempo = val;
                document.getElementById('drum-tempo-val').textContent = val;
            }
            
            function clearDrums() {
                drumSequence = drumSequence.map(track => track.map(() => 0));
                document.querySelectorAll('#drum-sequencer .step').forEach(el => {
                    el.classList.remove('active');
                });
            }
            
            // === BASSLINE MAKER ===
            function buildBassSequencer() {
                const container = document.getElementById('bass-sequencer');
                container.innerHTML = '';
                
                for (let i = 0; i < 16; i++) {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = 'bass-step';
                    if ((i + 1) % 4 === 0 && i < 15) stepDiv.classList.add('beat-4');
                    
                    const bar = document.createElement('div');
                    bar.className = 'bass-bar';
                    bar.style.height = '0%';
                    
                    const label = document.createElement('div');
                    label.className = 'bass-note-label';
                    label.textContent = '';
                    
                    stepDiv.appendChild(bar);
                    stepDiv.appendChild(label);
                    
                    if (bassSequence[i].active) {
                        stepDiv.classList.add('active');
                        const height = ((bassSequence[i].note + 1) / 12) * 100;
                        bar.style.height = height + '%';
                        label.textContent = notes[bassSequence[i].note];
                    }
                    
                    let isDragging = false;
                    let startY = 0;
                    let startNote = 0;
                    
                    stepDiv.onmousedown = (e) => {
                        e.preventDefault();
                        isDragging = true;
                        startY = e.clientY;
                        startNote = bassSequence[i].note;
                        
                        if (!bassSequence[i].active) {
                            bassSequence[i].active = 1;
                            bassSequence[i].note = 0; // Start at C
                            stepDiv.classList.add('active');
                            bar.style.height = '10%';
                            label.textContent = notes[0];
                        }
                    };
                    
                    document.addEventListener('mousemove', (e) => {
                        if (isDragging) {
                            const delta = startY - e.clientY;
                            const noteChange = Math.floor(delta / 10);
                            bassSequence[i].note = Math.max(0, Math.min(11, startNote + noteChange));
                            
                            const height = ((bassSequence[i].note + 1) / 12) * 100;
                            bar.style.height = height + '%';
                            label.textContent = notes[bassSequence[i].note];
                        }
                    });
                    
                    document.addEventListener('mouseup', () => {
                        isDragging = false;
                    });
                    
                    stepDiv.ondblclick = () => {
                        bassSequence[i].active = 0;
                        stepDiv.classList.remove('active');
                        bar.style.height = '0%';
                        label.textContent = '';
                    };
                    
                    container.appendChild(stepDiv);
                }
            }
            
            function toggleBass() {
                bassPlaying = !bassPlaying;
                const btn = document.getElementById('bass-play');
                
                if (bassPlaying) {
                    btn.textContent = 'STOP';
                    btn.classList.add('active');
                    bassStep = 0;
                    bassLoop();
                } else {
                    btn.textContent = 'PLAY';
                    btn.classList.remove('active');
                    clearTimeout(bassTimeout);
                    clearBassIndicators();
                }
            }
            
            function bassLoop() {
                if (!bassPlaying) return;
                
                clearBassIndicators();
                
                if (bassSequence[bassStep].active) {
                    const root = document.getElementById('bass-root').value;
                    const rootIndex = notes.indexOf(root);
                    const note = bassSequence[bassStep].note;
                    const midiNote = 36 + rootIndex + note; // C2 + root offset + note
                    
                    playBassNote(midiNote);
                    
                    const steps = document.querySelectorAll('#bass-sequencer .bass-step');
                    steps[bassStep].classList.add('playing');
                }
                
                bassStep = (bassStep + 1) % 16;
                const stepTime = (60 / drumTempo) / 4 * 1000;
                bassTimeout = setTimeout(bassLoop, stepTime);
            }
            
            function clearBassIndicators() {
                document.querySelectorAll('#bass-sequencer .bass-step.playing').forEach(el => {
                    el.classList.remove('playing');
                });
            }
            
            function playBassNote(midiNote) {
                const now = audioCtx.currentTime;
                const freq = 440 * Math.pow(2, (midiNote - 69) / 12);
                
                const osc = audioCtx.createOscillator();
                osc.type = bassWave;
                osc.frequency.value = freq;
                
                // Use filter settings from controls
                const filter = audioCtx.createBiquadFilter();
                filter.type = bassFilterType;
                filter.Q.value = bassFilterResonance;
                
                // Apply filter envelope
                if (bassFilterEnvelope > 0) {
                    filter.frequency.setValueAtTime(bassFilterCutoff, now);
                    filter.frequency.exponentialRampToValueAtTime(
                        Math.min(bassFilterCutoff + bassFilterEnvelope, 20000), 
                        now + 0.05
                    );
                    filter.frequency.exponentialRampToValueAtTime(bassFilterCutoff, now + 0.3);
                } else {
                    filter.frequency.value = bassFilterCutoff;
                }
                
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.6, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(masterReverb);
                gain.connect(audioCtx.destination);
                osc.start(now);
                osc.stop(now + 0.4);
            }
            
            function setBassWave(wave) {
                bassWave = wave;
            }
            
            function setBassFilterType(type) {
                bassFilterType = type;
            }
            
            function setBassFilterCutoff(value) {
                bassFilterCutoff = parseFloat(value);
                document.getElementById('bass-cutoff-val').textContent = value + ' Hz';
            }
            
            function setBassFilterResonance(value) {
                bassFilterResonance = parseFloat(value);
                document.getElementById('bass-res-val').textContent = value;
            }
            
            function setBassFilterEnvelope(value) {
                bassFilterEnvelope = parseFloat(value);
                document.getElementById('bass-env-val').textContent = value + ' Hz';
            }
            
            function clearBass() {
                bassSequence = bassSequence.map(() => ({ active: 0, note: 0 }));
                buildBassSequencer();
            }
            
            function randomBass() {
                const scale = scales[document.getElementById('bass-scale').value];
                
                for (let i = 0; i < 16; i++) {
                    bassSequence[i].active = Math.random() > 0.5 ? 1 : 0;
                    if (bassSequence[i].active) {
                        const scaleNote = scale[Math.floor(Math.random() * scale.length)];
                        bassSequence[i].note = scaleNote;
                    }
                }
                buildBassSequencer();
            }
            
            // Bass presets
            function loadBassPreset(preset) {
                if (!preset) return;
                
                const presets = {
                    techno: [
                        { step: 0, note: 0 },
                        { step: 4, note: 0 },
                        { step: 8, note: 0 },
                        { step: 12, note: 0 },
                        { step: 14, note: 7 }
                    ],
                    house: [
                        { step: 0, note: 0 },
                        { step: 2, note: 7 },
                        { step: 4, note: 0 },
                        { step: 6, note: 7 },
                        { step: 8, note: 0 },
                        { step: 10, note: 7 },
                        { step: 12, note: 0 },
                        { step: 14, note: 7 }
                    ],
                    dnb: [
                        { step: 0, note: 0 },
                        { step: 1, note: 7 },
                        { step: 4, note: 0 },
                        { step: 6, note: 5 },
                        { step: 8, note: 0 },
                        { step: 10, note: 7 },
                        { step: 12, note: 3 },
                        { step: 14, note: 7 }
                    ],
                    acid: [
                        { step: 0, note: 0 },
                        { step: 2, note: 3 },
                        { step: 4, note: 5 },
                        { step: 6, note: 7 },
                        { step: 8, note: 10 },
                        { step: 10, note: 7 },
                        { step: 12, note: 5 },
                        { step: 14, note: 3 }
                    ],
                    minimal: [
                        { step: 0, note: 0 },
                        { step: 8, note: 7 }
                    ],
                    trance: [
                        { step: 0, note: 0 },
                        { step: 1, note: 7 },
                        { step: 2, note: 3 },
                        { step: 3, note: 10 },
                        { step: 4, note: 7 },
                        { step: 5, note: 3 },
                        { step: 6, note: 0 },
                        { step: 7, note: 7 },
                        { step: 8, note: 0 },
                        { step: 9, note: 7 },
                        { step: 10, note: 3 },
                        { step: 11, note: 10 },
                        { step: 12, note: 7 },
                        { step: 13, note: 3 },
                        { step: 14, note: 0 },
                        { step: 15, note: 7 }
                    ]
                };
                
                bassSequence = bassSequence.map(() => ({ active: 0, note: 0 }));
                presets[preset].forEach(({ step, note }) => {
                    bassSequence[step].active = 1;
                    bassSequence[step].note = note;
                });
                
                buildBassSequencer();
                document.getElementById('bass-preset').value = '';
            }
            
            // Record bass pattern as WAV
            function recordBass() {
                if (bassRecording) {
                    // Stop recording
                    bassRecording = false;
                    bassRecorder.stop();
                    document.getElementById('bass-record').textContent = '‚óè RECORD';
                    document.getElementById('bass-record').classList.remove('active');
                } else {
                    // Start recording
                    bassRecording = true;
                    bassRecordingChunks = [];
                    
                    const dest = audioCtx.createMediaStreamDestination();
                    
                    // Temporarily connect audio to recorder
                    const oldPlayBassNote = playBassNote;
                    window.tempRecordConnection = dest;
                    
                    bassRecorder = new MediaRecorder(dest.stream);
                    bassRecorder.ondataavailable = (e) => {
                        bassRecordingChunks.push(e.data);
                    };
                    
                    bassRecorder.onstop = () => {
                        const blob = new Blob(bassRecordingChunks, { type: 'audio/wav' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'bass_pattern_' + Date.now() + '.wav';
                        a.click();
                        window.tempRecordConnection = null;
                    };
                    
                    bassRecorder.start();
                    document.getElementById('bass-record').textContent = '‚ñ† STOP REC';
                    document.getElementById('bass-record').classList.add('active');
                    
                    // Auto-stop after 4 bars (64 steps)
                    setTimeout(() => {
                        if (bassRecording) {
                            recordBass();
                        }
                    }, (60 / drumTempo) * 16 * 1000);
                }
            }
            
            // === AI GENERATION SYSTEM ===
            
            // Euclidean rhythm algorithm
            function euclideanRhythm(steps, pulses) {
                const pattern = Array(steps).fill(0);
                if (pulses >= steps) {
                    pattern.fill(1);
                    return pattern;
                }
                
                const slope = pulses / steps;
                for (let i = 0; i < steps; i++) {
                    if (Math.floor(i * slope) !== Math.floor((i - 1) * slope)) {
                        pattern[i] = 1;
                    }
                }
                return pattern;
            }
            
            // Generate drum pattern based on style
            function generateDrumPattern() {
                const style = document.getElementById('gen-style').value;
                
                const patterns = {
                    idm: {
                        kick: euclideanRhythm(16, 5),
                        snare: euclideanRhythm(16, 3),
                        hihat: euclideanRhythm(16, 11),
                        perc: euclideanRhythm(16, 7)
                    },
                    techno: {
                        kick: [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
                        snare: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
                        hihat: [1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1],
                        perc: [0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1]
                    },
                    house: {
                        kick: [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
                        snare: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
                        hihat: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                        perc: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0]
                    },
                    dnb: {
                        kick: [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                        snare: [0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0],
                        hihat: euclideanRhythm(16, 13),
                        perc: euclideanRhythm(16, 9)
                    },
                    ambient: {
                        kick: [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        snare: [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                        hihat: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],
                        perc: [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0]
                    },
                    glitch: {
                        kick: euclideanRhythm(16, Math.floor(Math.random() * 8) + 3),
                        snare: euclideanRhythm(16, Math.floor(Math.random() * 6) + 2),
                        hihat: euclideanRhythm(16, Math.floor(Math.random() * 12) + 8),
                        perc: euclideanRhythm(16, Math.floor(Math.random() * 10) + 4)
                    }
                };
                
                const pattern = patterns[style];
                drumSequence[0] = pattern.kick;
                drumSequence[1] = pattern.snare;
                drumSequence[2] = pattern.hihat;
                drumSequence[3] = pattern.perc;
                
                buildDrumSequencer();
            }
            
            // Generate bassline with musical scale
            function generateBassline() {
                const scaleType = document.getElementById('bass-scale').value;
                const scale = scales[scaleType];
                
                // Generate pattern
                for (let i = 0; i < 16; i++) {
                    const shouldPlay = Math.random() > 0.4;
                    bassSequence[i].active = shouldPlay ? 1 : 0;
                    
                    if (shouldPlay) {
                        // Pick note from scale (0-11)
                        const scaleNote = scale[Math.floor(Math.random() * scale.length)];
                        bassSequence[i].note = scaleNote;
                    }
                }
                
                buildBassSequencer();
            }
            
            // Generate full composition
            // === AI PREVIEW SYSTEM (SEPARATE) ===
            
            // === AI IMAGE & VIDEO GENERATOR ===
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // üîÅ MULTI-TRACK LOOPER SYSTEM
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            const looperTracks = {
                drums: { buffer: null, source: null, recorder: null, recording: false, playing: false, chunks: [], volume: 0.8, muted: false },
                bass: { buffer: null, source: null, recorder: null, recording: false, playing: false, chunks: [], volume: 0.8, muted: false },
                lead: { buffer: null, source: null, recorder: null, recording: false, playing: false, chunks: [], volume: 0.8, muted: false },
                pad: { buffer: null, source: null, recorder: null, recording: false, playing: false, chunks: [], volume: 0.8, muted: false }
            };
            
            let looperMetronome = false;
            let looperDestination = null;
            
            function looperRecord(trackName) {
                const track = looperTracks[trackName];
                if (!audioCtx) {
                    alert('Audio context not initialized!');
                    return;
                }
                
                if (track.recording) {
                    // Stop recording
                    looperStopRecording(trackName);
                    return;
                }
                
                // Start recording
                track.chunks = [];
                track.recording = true;
                updateLooperStatus(trackName, 'RECORDING ‚è∫');
                
                // Create destination for recording
                looperDestination = audioCtx.createMediaStreamDestination();
                masterGain.connect(looperDestination);
                
                // Create recorder
                track.recorder = new MediaRecorder(looperDestination.stream);
                
                track.recorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        track.chunks.push(e.data);
                    }
                };
                
                track.recorder.onstop = () => {
                    const blob = new Blob(track.chunks, { type: 'audio/webm' });
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        audioCtx.decodeAudioData(reader.result.slice(0), (buffer) => {
                            track.buffer = buffer;
                            drawWaveform(trackName, buffer);
                            updateLooperStatus(trackName, 'READY');
                        });
                    };
                    reader.readAsArrayBuffer(blob);
                };
                
                track.recorder.start();
                
                // Auto-stop based on loop length
                const bars = parseInt(document.getElementById('looper-bars').value) || 4;
                const bpm = parseInt(document.getElementById('master-tempo')?.value) || 120;
                const duration = (60 / bpm) * 4 * bars * 1000; // milliseconds
                
                setTimeout(() => {
                    if (track.recording) {
                        looperStopRecording(trackName);
                    }
                }, duration);
            }
            
            function looperStopRecording(trackName) {
                const track = looperTracks[trackName];
                if (track.recorder && track.recording) {
                    track.recorder.stop();
                    track.recording = false;
                    if (looperDestination) {
                        masterGain.disconnect(looperDestination);
                    }
                }
            }
            
            function looperPlay(trackName) {
                const track = looperTracks[trackName];
                if (!track.buffer) {
                    alert('No recording on this track!');
                    return;
                }
                
                if (track.playing) {
                    looperStop(trackName);
                    return;
                }
                
                track.playing = true;
                updateLooperStatus(trackName, 'PLAYING ‚ñ∂');
                
                function playLoop() {
                    if (!track.playing) return;
                    
                    const source = audioCtx.createBufferSource();
                    source.buffer = track.buffer;
                    
                    const gainNode = audioCtx.createGain();
                    gainNode.gain.value = track.muted ? 0 : track.volume;
                    
                    source.connect(gainNode);
                    gainNode.connect(audioCtx.destination);
                    
                    track.source = source;
                    source.start();
                    
                    source.onended = () => {
                        if (track.playing) {
                            playLoop();
                        }
                    };
                }
                
                playLoop();
            }
            
            function looperStop(trackName) {
                const track = looperTracks[trackName];
                track.playing = false;
                if (track.source) {
                    try {
                        track.source.stop();
                    } catch (e) {}
                    track.source = null;
                }
                updateLooperStatus(trackName, 'READY');
            }
            
            function looperSetVolume(trackName, value) {
                looperTracks[trackName].volume = value / 100;
            }
            
            function looperMute(trackName) {
                const track = looperTracks[trackName];
                track.muted = !track.muted;
                const btn = document.getElementById(`looper-${trackName}-mute`);
                if (btn) {
                    btn.textContent = track.muted ? 'UNMUTE' : 'MUTE';
                    btn.style.background = track.muted ? '#ff0055' : '';
                }
            }
            
            function looperRecordAll() {
                Object.keys(looperTracks).forEach(track => {
                    if (!looperTracks[track].buffer) {
                        looperRecord(track);
                    }
                });
            }
            
            function looperStopAll() {
                Object.keys(looperTracks).forEach(track => {
                    looperStop(track);
                });
            }
            
            function looperClearAll() {
                if (!confirm('Clear all tracks?')) return;
                Object.keys(looperTracks).forEach(track => {
                    looperStop(track);
                    looperTracks[track].buffer = null;
                    looperTracks[track].chunks = [];
                    document.getElementById(`looper-${track}-wave`).innerHTML = '<div style="color: #333; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 11px;">NO RECORDING</div>';
                    updateLooperStatus(track, 'READY');
                });
            }
            
            function looperExport() {
                alert('Export Mix feature coming soon! This will render all tracks to a single WAV/MP3 file.');
            }
            
            function looperToggleMetronome() {
                looperMetronome = !looperMetronome;
                const btn = document.getElementById('looper-metronome');
                if (btn) {
                    btn.textContent = looperMetronome ? 'ON' : 'OFF';
                    btn.style.background = looperMetronome ? '#00ff85' : '';
                }
            }
            
            function updateLooperStatus(trackName, status) {
                const el = document.getElementById(`looper-${trackName}-status`);
                if (el) {
                    el.textContent = status;
                    el.style.color = status.includes('RECORDING') ? '#ff0055' : 
                                     status.includes('PLAYING') ? '#00ff85' : '#666';
                }
            }
            
            function drawWaveform(trackName, buffer) {
                const canvas = document.getElementById(`looper-${trackName}-wave`);
                if (!canvas) return;
                
                canvas.innerHTML = '';
                const ctx = document.createElement('canvas').getContext('2d');
                const waveCanvas = document.createElement('canvas');
                waveCanvas.width = canvas.clientWidth;
                waveCanvas.height = canvas.clientHeight;
                waveCanvas.style.width = '100%';
                waveCanvas.style.height = '100%';
                canvas.appendChild(waveCanvas);
                
                const waveCtx = waveCanvas.getContext('2d');
                const data = buffer.getChannelData(0);
                const step = Math.ceil(data.length / waveCanvas.width);
                const amp = waveCanvas.height / 2;
                
                waveCtx.fillStyle = '#000';
                waveCtx.fillRect(0, 0, waveCanvas.width, waveCanvas.height);
                
                waveCtx.strokeStyle = trackName === 'drums' ? '#ff0055' :
                                      trackName === 'bass' ? '#00ff85' :
                                      trackName === 'lead' ? '#0ff' : '#ff00ff';
                waveCtx.lineWidth = 1;
                waveCtx.beginPath();
                
                for (let i = 0; i < waveCanvas.width; i++) {
                    let min = 1.0;
                    let max = -1.0;
                    for (let j = 0; j < step; j++) {
                        const datum = data[(i * step) + j];
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                    waveCtx.lineTo(i, (1 + min) * amp);
                    waveCtx.lineTo(i, (1 + max) * amp);
                }
                
                waveCtx.stroke();
            }
            
            // Play all sequencers
            
            // Play all sequencers
            function playAllSequencers() {
                if (!drumPlaying) toggleDrums();
                if (!bassPlaying) toggleBass();
            }
            
            // Stop all sequencers
            function stopAllSequencers() {
                if (drumPlaying) toggleDrums();
                if (bassPlaying) toggleBass();
            }
            
            // Set humanization
            function setHumanize(value) {
                humanize = parseFloat(value);
                document.getElementById('humanize-val').textContent = value + '%';
            }
            
            // === CURSOR SYNTH ===
            function setupSynthCanvas() {
                const canvas = document.getElementById('synth-canvas');
                let isPlaying = false;
                
                canvas.addEventListener('mousedown', (e) => {
                    isPlaying = true;
                    startSynth(e);
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    updateSynthDisplay(e);
                    if (isPlaying) updateSynthParams(e);
                });
                
                canvas.addEventListener('mouseup', () => {
                    isPlaying = false;
                    stopSynth();
                });
                
                canvas.addEventListener('mouseleave', () => {
                    isPlaying = false;
                    stopSynth();
                });
            }
            
            function startSynth(e) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const freq = (x / rect.width) * 1000 + 100;
                const filterFreq = 5000 - (y / rect.height) * 4500;
                
                // Oscillator
                synthOsc = audioCtx.createOscillator();
                synthOsc.type = document.getElementById('synth-wave').value;
                synthOsc.frequency.value = freq;
                
                // LFO
                synthLFO = audioCtx.createOscillator();
                synthLFO.frequency.value = parseFloat(document.getElementById('lfo-rate').value);
                synthLFOGain = audioCtx.createGain();
                synthLFOGain.gain.value = parseFloat(document.getElementById('lfo-depth').value);
                synthLFO.connect(synthLFOGain);
                synthLFOGain.connect(synthOsc.frequency);
                
                // Filter
                synthFilter = audioCtx.createBiquadFilter();
                synthFilter.type = 'lowpass';
                synthFilter.frequency.value = filterFreq;
                synthFilter.Q.value = 10;
                
                // Distortion
                synthDistortion = audioCtx.createWaveShaper();
                const distAmount = parseFloat(document.getElementById('distortion').value);
                synthDistortion.curve = makeDistortionCurve(distAmount);
                
                // Delay
                synthDelay = audioCtx.createDelay();
                synthDelay.delayTime.value = parseFloat(document.getElementById('delay-time').value) / 1000;
                synthFeedback = audioCtx.createGain();
                synthFeedback.gain.value = parseFloat(document.getElementById('delay-feedback').value) / 100;
                synthDelay.connect(synthFeedback);
                synthFeedback.connect(synthDelay);
                
                // Reverb
                synthReverb = audioCtx.createConvolver();
                synthReverb.buffer = masterReverb.buffer;
                const reverbWet = audioCtx.createGain();
                reverbWet.gain.value = parseFloat(document.getElementById('synth-reverb').value) / 100;
                
                // Main gain
                synthGain = audioCtx.createGain();
                const attack = parseFloat(document.getElementById('synth-attack').value) / 1000;
                synthGain.gain.setValueAtTime(0, audioCtx.currentTime);
                synthGain.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + attack);
                
                // Connect chain
                synthOsc.connect(synthFilter);
                synthFilter.connect(synthDistortion);
                synthDistortion.connect(synthGain);
                synthGain.connect(synthDelay);
                synthDelay.connect(audioCtx.destination);
                synthGain.connect(reverbWet);
                reverbWet.connect(synthReverb);
                synthReverb.connect(audioCtx.destination);
                synthGain.connect(audioCtx.destination); // Dry
                
                synthOsc.start();
                synthLFO.start();
            }
            
            function updateSynthParams(e) {
                if (!synthOsc) return;
                
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const freq = (x / rect.width) * 1000 + 100;
                const filterFreq = 5000 - (y / rect.height) * 4500;
                
                synthOsc.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.01);
                synthFilter.frequency.setTargetAtTime(filterFreq, audioCtx.currentTime, 0.01);
            }
            
            function stopSynth() {
                if (synthOsc && synthGain) {
                    synthGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                    setTimeout(() => {
                        if (synthOsc) {
                            synthOsc.stop();
                            synthLFO.stop();
                            synthOsc = null;
                        }
                    }, 200);
                }
            }
            
            function updateSynthDisplay(e) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const freq = Math.round((x / rect.width) * 1000 + 100);
                const filterFreq = Math.round(5000 - (y / rect.height) * 4500);
                
                document.getElementById('synth-freq').textContent = freq;
                document.getElementById('synth-filter').textContent = filterFreq;
            }
            
            function updateSynth() {
                document.getElementById('lfo-rate-val').textContent = document.getElementById('lfo-rate').value + ' Hz';
                document.getElementById('lfo-depth-val').textContent = document.getElementById('lfo-depth').value;
                document.getElementById('distortion-val').textContent = document.getElementById('distortion').value + '%';
                document.getElementById('delay-time-val').textContent = document.getElementById('delay-time').value + 'ms';
                document.getElementById('delay-fb-val').textContent = document.getElementById('delay-feedback').value + '%';
                document.getElementById('synth-reverb-val').textContent = document.getElementById('synth-reverb').value + '%';
                document.getElementById('synth-attack-val').textContent = document.getElementById('synth-attack').value + 'ms';
            }
            
            function makeDistortionCurve(amount) {
                const samples = 44100;
                const curve = new Float32Array(samples);
                const deg = Math.PI / 180;
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2) / samples - 1;
                    curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
                }
                return curve;
            }
            
            // === LIVE CODING ===
            let codeTimeouts = [];
            let codeLooping = false;
            let codeLoopTimeout = null;
            
            function executeCode() {
                const code = document.getElementById('code-input').value;
                const output = document.getElementById('code-output');
                
                // Clear any previous execution
                codeTimeouts.forEach(t => clearTimeout(t));
                codeTimeouts = [];
                
                if (!codeLooping) {
                    output.textContent = '> Executing code...\n';
                }
                
                try {
                    // Execution state
                    const state = { currentTime: 0, bpm: 120 };
                    
                    // Create a function that wraps the code with our API
                    const wrappedCode = `
                        (function() {
                            const state = arguments[0];
                            const playCodeSound = arguments[1];
                            const playTone = arguments[2];
                            const output = arguments[3];
                            const codeTimeouts = arguments[4];
                            const playSynthNote = arguments[5];
                            
                            function play(sound) {
                                const execTime = state.currentTime;
                                const timeout = setTimeout(() => {
                                    playCodeSound(sound);
                                    output.textContent += '‚úì [' + (execTime/1000).toFixed(2) + 's] ' + sound + '\\n';
                                }, execTime);
                                codeTimeouts.push(timeout);
                            }
                            
                            function synth(type, note, velocity = 1) {
                                const execTime = state.currentTime;
                                const timeout = setTimeout(() => {
                                    playSynthNote(note, velocity, type);
                                    output.textContent += '‚ô™ [' + (execTime/1000).toFixed(2) + 's] ' + type + ' ' + note + '\\n';
                                }, execTime);
                                codeTimeouts.push(timeout);
                            }
                            
                            function wait(seconds) {
                                state.currentTime += seconds * 1000;
                            }
                            
                            function beat(beats) {
                                // Wait based on BPM (beats = quarter notes)
                                const secondsPerBeat = 60 / state.bpm;
                                state.currentTime += beats * secondsPerBeat * 1000;
                            }
                            
                            function bpm(newBpm) {
                                state.bpm = newBpm;
                                output.textContent += '‚ö° BPM set to ' + newBpm + '\\n';
                            }
                            
                            function tone(freq, duration) {
                                const execTime = state.currentTime;
                                const timeout = setTimeout(() => {
                                    playTone(freq, duration);
                                    output.textContent += '‚úì [' + (execTime/1000).toFixed(2) + 's] tone ' + freq + 'Hz\\n';
                                }, execTime);
                                codeTimeouts.push(timeout);
                            }
                            
                            function loop(times, fn) {
                                for (let i = 0; i < times; i++) {
                                    fn();
                                }
                            }
                            
                            // User code starts here
                            ${code}
                        })
                    `;
                    
                    // Execute the wrapped code
                    const fn = eval(wrappedCode);
                    fn(state, playCodeSound, playTone, output, codeTimeouts, playSynthNote);
                    
                    // Schedule completion or loop restart
                    const finalTimeout = setTimeout(() => {
                        if (codeLooping) {
                            output.textContent += '> Loop cycle complete, restarting...\\n';
                            codeLoopTimeout = setTimeout(() => executeCode(), 100);
                        } else {
                            output.textContent += '\n> Execution complete!';
                        }
                    }, state.currentTime + 100);
                    codeTimeouts.push(finalTimeout);
                    
                } catch (e) {
                    output.textContent += '\n‚úó Error: ' + e.message;
                    console.error('Live coding error:', e);
                    codeLooping = false;
                    updateLoopButton();
                }
            }
            
            function toggleCodeLoop() {
                codeLooping = !codeLooping;
                updateLoopButton();
                
                if (codeLooping) {
                    executeCode();
                } else {
                    clearTimeout(codeLoopTimeout);
                }
            }
            
            function updateLoopButton() {
                const btn = document.getElementById('loop-btn');
                if (btn) {
                    btn.textContent = codeLooping ? 'LOOP: ON' : 'LOOP: OFF';
                    if (codeLooping) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            }
            
            function playCodeSound(name) {
                const sounds = {
                    kick: 0,
                    snare: 1,
                    hihat: 2,
                    perc: 3
                };
                
                if (sounds[name] !== undefined) {
                    playDrumSound(sounds[name], drumKit);
                } else if (name === 'bass') {
                    playBassNote(50);
                } else if (name === 'clap') {
                    playClap();
                } else if (name === 'rim') {
                    playRim();
                }
            }
            
            function playClap() {
                const now = audioCtx.currentTime;
                const noise = createNoise(0.1);
                const gain = audioCtx.createGain();
                
                // Double hit for clap effect
                gain.gain.setValueAtTime(0.8, now);
                gain.gain.setValueAtTime(0, now + 0.02);
                gain.gain.setValueAtTime(0.7, now + 0.04);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                
                noise.connect(gain).connect(audioCtx.destination);
                noise.start(now);
                noise.stop(now + 0.1);
            }
            
            function playRim() {
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                osc.type = 'square';
                osc.frequency.value = 400;
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                osc.connect(gain).connect(audioCtx.destination);
                osc.start(now);
                osc.stop(now + 0.08);
            }
            
            // MIDI note to frequency
            function midiToFreq(note) {
                return 440 * Math.pow(2, (note - 69) / 12);
            }
            
            // Synth voices for live coding
            function playSynthNote(note, velocity = 1, synthType = 'bass') {
                const now = audioCtx.currentTime;
                const freq = midiToFreq(note);
                const duration = 0.5;
                
                const osc = audioCtx.createOscillator();
                const filter = audioCtx.createBiquadFilter();
                const gain = audioCtx.createGain();
                
                if (synthType === 'bass') {
                    osc.type = 'sawtooth';
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(freq * 2, now);
                    filter.frequency.exponentialRampToValueAtTime(freq, now + 0.2);
                    filter.Q.value = 5;
                    gain.gain.setValueAtTime(0.5 * velocity, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                    
                } else if (synthType === 'lead') {
                    osc.type = 'square';
                    filter.type = 'lowpass';
                    filter.frequency.value = freq * 4;
                    filter.Q.value = 10;
                    gain.gain.setValueAtTime(0.3 * velocity, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                    
                } else if (synthType === 'pad') {
                    osc.type = 'sine';
                    filter.type = 'lowpass';
                    filter.frequency.value = freq * 3;
                    filter.Q.value = 2;
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.2 * velocity, now + 0.1);
                    gain.gain.setValueAtTime(0.2 * velocity, now + 0.8);
                    gain.gain.linearRampToValueAtTime(0.01, now + 1.2);
                    
                } else if (synthType === 'pluck') {
                    osc.type = 'sawtooth';
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(freq * 8, now);
                    filter.frequency.exponentialRampToValueAtTime(freq, now + 0.1);
                    filter.Q.value = 8;
                    gain.gain.setValueAtTime(0.4 * velocity, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    
                } else if (synthType === 'stab') {
                    osc.type = 'square';
                    filter.type = 'lowpass';
                    filter.frequency.value = freq * 6;
                    filter.Q.value = 15;
                    gain.gain.setValueAtTime(0.5 * velocity, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                }
                
                osc.frequency.value = freq;
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(masterReverb);
                gain.connect(audioCtx.destination);
                
                osc.start(now);
                osc.stop(now + (synthType === 'pad' ? 1.2 : duration));
            }
            
            function playTone(freq, duration) {
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                
                osc.connect(gain).connect(audioCtx.destination);
                osc.start(now);
                osc.stop(now + duration);
            }
            
            function stopCode() {
                codeTimeouts.forEach(t => clearTimeout(t));
                codeTimeouts = [];
                codeLooping = false;
                clearTimeout(codeLoopTimeout);
                updateLoopButton();
                document.getElementById('code-output').textContent = '> Stopped.';
            }
            
            function clearCode() {
                document.getElementById('code-input').value = '';
                document.getElementById('code-output').textContent = '> Code cleared.';
            }
            
            function loadExample() {
                const example = `// Set BPM
bpm(128)

// Drums
play('kick')
beat(1)
play('snare')
beat(1)

// Bassline (MIDI notes)
synth('bass', 48)  // C2
beat(0.5)
synth('bass', 55)  // G2
beat(0.5)

// Lead melody
synth('lead', 72)  // C4
beat(0.25)
synth('lead', 74)  // D4
beat(0.25)

// Try: bass, lead, pad, pluck, stab
// Also: clap, rim`;
                
                document.getElementById('code-input').value = example;
                document.getElementById('code-output').textContent = '> Example loaded. Press Ctrl+Enter or enable LOOP mode!';
            }
            
            // === VISUAL REACTOR ===
            function setupVisualCanvas() {
                visualCanvas = document.getElementById('visual-canvas');
                visualCtx = visualCanvas.getContext('2d');
                visualCanvas.width = visualCanvas.offsetWidth;
                visualCanvas.height = visualCanvas.offsetHeight;
                
                animateVisual();
            }
            
            function animateVisual() {
                visualCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                visualCtx.fillRect(0, 0, visualCanvas.width, visualCanvas.height);
                
                if (isReactive && analyser) {
                    analyser.getByteFrequencyData(dataArray);
                    
                    const barWidth = visualCanvas.width / dataArray.length;
                    for (let i = 0; i < dataArray.length; i++) {
                        const barHeight = (dataArray[i] / 255) * visualCanvas.height;
                        const hue = (i / dataArray.length) * 360;
                        
                        visualCtx.fillStyle = `hsla(${hue}, 70%, 50%, 0.6)`;
                        visualCtx.fillRect(
                            i * barWidth,
                            visualCanvas.height - barHeight,
                            barWidth - 2,
                            barHeight
                        );
                    }
                } else {
                    // Generative visuals when not reactive
                    for (let i = 0; i < 3; i++) {
                        visualCtx.beginPath();
                        visualCtx.arc(
                            Math.random() * visualCanvas.width,
                            Math.random() * visualCanvas.height,
                            Math.random() * 50 + 10,
                            0,
                            Math.PI * 2
                        );
                        visualCtx.fillStyle = `hsla(${Math.random() * 360}, 70%, 50%, 0.2)`;
                        visualCtx.fill();
                    }
                }
                
                requestAnimationFrame(animateVisual);
            }
            
            function generateVisual() {
                const prompt = document.getElementById('visual-prompt').value;
                const loading = document.getElementById('visual-loading');
                
                loading.classList.add('active');
                
                // Simulate generation
                setTimeout(() => {
                    loading.classList.remove('active');
                    alert('For real Krea.ai integration, add your API key. Currently showing generative visuals.');
                }, 2000);
            }
            
            function randomPrompt() {
                const prompts = [
                    'cyberpunk neon city',
                    'abstract particles flowing',
                    'glitch art digital',
                    'vaporwave aesthetic',
                    'holographic interface',
                    'fractal patterns'
                ];
                document.getElementById('visual-prompt').value = prompts[Math.floor(Math.random() * prompts.length)];
            }
            
            function toggleReactive() {
                isReactive = !isReactive;
                const btn = document.getElementById('react-toggle');
                btn.textContent = 'MUSIC REACTIVE: ' + (isReactive ? 'ON' : 'OFF');
                btn.classList.toggle('active');
            }
            
            // === KEYBOARD SHORTCUTS ===
            function setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === 'Enter') {
                        executeCode();
                    }
                    if (e.key === ' ' && !e.target.matches('textarea, input')) {
                        e.preventDefault();
                        toggleDrums();
                    }
                });
            }
            
            // Init on load - DISABLED (called manually when entering studio)
            // window.addEventListener('load', init);
            
            return {
                init,
                toggleDrums,
                setDrumKit,
                setDrumTempo,
                clearDrums,
                generateDrumPattern,
                setHumanize,
                toggleBass,
                setBassWave,
                setBassFilterType,
                setBassFilterCutoff,
                setBassFilterResonance,
                setBassFilterEnvelope,
                clearBass,
                randomBass,
                loadBassPreset,
                recordBass,
                generateBassline,
                looperRecord,
                looperPlay,
                looperStop,
                looperSetVolume,
                looperMute,
                looperRecordAll,
                looperStopAll,
                looperClearAll,
                looperExport,
                looperToggleMetronome,
                playAllSequencers,
                stopAllSequencers,
                updateSynth,
                executeCode,
                toggleCodeLoop,
                stopCode,
                clearCode,
                loadExample,
                detectMIDI,
                connectSelectedMIDI,
                setMIDITarget,
                enableMIDILearn,
                connectMIDI,
                cycleVisualMode,
                randomColors,
                setVisualIntensity,
                setVisualSpeed,
                toggleReactive
            };
        })();
    </script>
    </div> <!-- END STUDIO CONTAINER -->

    <!-- MOTION_AI CONTAINER -->
    <div id="motion-ai-container" style="display: none; position: fixed; inset: 0; background: #000; z-index: 1;">
        <!-- Full-screen WebGL Canvas -->
        <canvas id="motion-canvas" style="position: absolute; inset: 0; width: 100%; height: 100%;"></canvas>
        
        <!-- Controls Overlay -->
        <div style="position: absolute; top: 20px; left: 20px; right: 20px; z-index: 10; pointer-events: none;">
            <div style="font-family: 'Bebas Neue'; font-size: 48px; color: var(--accent); letter-spacing: 8px; text-shadow: 0 0 20px var(--accent);">
                MOTION_AI
            </div>
            <div style="font-size: 12px; color: var(--accent); letter-spacing: 3px; opacity: 0.7; margin-top: 5px;">
                GENERATIVE VISUAL SYSTEM | MIDI CONTROLLED | AUDIO REACTIVE
            </div>
        </div>

        <!-- Control Panel -->
        <div id="motion-controls" style="position: absolute; bottom: 20px; left: 20px; right: 20px; z-index: 10; background: rgba(0,0,0,0.8); border: 1px solid var(--accent); padding: 20px; backdrop-filter: blur(10px);">
            
            <!-- Prompt Input -->
            <div style="margin-bottom: 20px;">
                <input type="text" id="motion-prompt" placeholder="Enter visual prompt... (e.g., cosmic nebula, fractal tunnel, liquid metal)" 
                       style="width: 100%; background: #0a0a0a; border: 1px solid var(--accent); color: var(--accent); padding: 12px; font-family: 'JetBrains Mono'; font-size: 12px;">
            </div>

            <!-- Buttons Row -->
            <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                <button class="btn" onclick="MOTION.generateFromPrompt()">GENERATE</button>
                <button class="btn" onclick="MOTION.randomize()">RANDOMIZE</button>
                <button class="btn" id="auto-btn" onclick="MOTION.toggleAuto()">AUTO: OFF</button>
                <button class="btn" id="audio-btn" onclick="MOTION.toggleAudio()">AUDIO: OFF</button>
                <button class="btn" onclick="MOTION.freeze()">FREEZE</button>
                <button class="btn" onclick="showMotionHelp()">? HELP</button>
                <button class="btn" onclick="exitMotionAI()">‚Üê EXIT</button>
            </div>

            <!-- Presets and Controls Grid -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                
                <!-- Preset Styles -->
                <div style="background: #0a0a0a; padding: 15px; border: 1px solid #333;">
                    <div style="color: var(--accent); font-family: 'Bebas Neue'; margin-bottom: 10px; letter-spacing: 2px;">PRESETS</div>
                    <select class="btn" id="preset-select" onchange="MOTION.loadPreset(this.value)" style="width: 100%; margin-bottom: 5px;">
                        <option value="fractal">FRACTAL TUNNEL</option>
                        <option value="particles">PARTICLE FIELD</option>
                        <option value="plasma">PLASMA WAVES</option>
                        <option value="cyberpunk">CYBERPUNK GRID</option>
                        <option value="cosmic">COSMIC NEBULA</option>
                        <option value="liquid">LIQUID METAL</option>
                        <option value="glitch">GLITCH ART</option>
                        <option value="vaporwave">VAPORWAVE</option>
                    </select>
                </div>

                <!-- MIDI Controls -->
                <div style="background: #0a0a0a; padding: 15px; border: 1px solid #333;">
                    <div style="color: var(--accent); font-family: 'Bebas Neue'; margin-bottom: 10px; letter-spacing: 2px;">MIDI CONTROL</div>
                    <div style="font-size: 10px; color: var(--accent); opacity: 0.7;">
                        CC1: HUE | CC2: SAT | CC3: SPEED<br>
                        CC4: ZOOM | CC5: COMPLEXITY
                    </div>
                    <div id="midi-status-motion" style="margin-top: 10px; font-size: 11px; color: #666;">
                        ‚óã Disconnected
                    </div>
                    <button class="btn btn-small" onclick="MOTION.detectMIDI()" style="width: 100%; margin-top: 10px;">DETECT DEVICES</button>
                    <select class="btn btn-small" id="midi-device-select-motion" style="width: 100%; margin-top: 8px;" disabled>
                        <option value="">Click Detect Devices first</option>
                    </select>
                    <button class="btn btn-small" id="midi-connect-btn-motion" onclick="MOTION.connectSelectedMIDI()" style="width: 100%; margin-top: 8px;" disabled>CONNECT</button>
                </div>

                <!-- Parameters -->
                <div style="background: #0a0a0a; padding: 15px; border: 1px solid #333;">
                    <div style="color: var(--accent); font-family: 'Bebas Neue'; margin-bottom: 10px; letter-spacing: 2px;">PARAMETERS</div>
                    <div style="display: flex; flex-direction: column; gap: 8px; font-size: 10px;">
                        <div>
                            <label style="color: var(--accent); opacity: 0.8;">HUE: <span id="hue-val">180</span></label>
                            <input type="range" id="hue-slider" min="0" max="360" value="180" style="width: 100%;">
                        </div>
                        <div>
                            <label style="color: var(--accent); opacity: 0.8;">SPEED: <span id="speed-val">1.0</span></label>
                            <input type="range" id="speed-slider" min="0.1" max="5" step="0.1" value="1" style="width: 100%;">
                        </div>
                        <div>
                            <label style="color: var(--accent); opacity: 0.8;">ZOOM: <span id="zoom-val">1.0</span></label>
                            <input type="range" id="zoom-slider" min="0.5" max="3" step="0.1" value="1" style="width: 100%;">
                        </div>
                    </div>
                </div>

                <!-- Stats -->
                <div style="background: #0a0a0a; padding: 15px; border: 1px solid #333;">
                    <div style="color: var(--accent); font-family: 'Bebas Neue'; margin-bottom: 10px; letter-spacing: 2px;">STATS</div>
                    <div style="font-size: 11px; color: var(--accent); opacity: 0.7; line-height: 1.6;">
                        FPS: <span id="fps-display">60</span><br>
                        MODE: <span id="mode-display">FRACTAL</span><br>
                        AUDIO: <span id="audio-display">OFF</span><br>
                        AUTO: <span id="auto-display">OFF</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- VISUAL_LAB CONTAINER - TOUCH DESIGNER STYLE -->
    <div id="visual-lab-container" style="display: none; position: fixed; inset: 0; background: #0a0a0a; z-index: 1; overflow: hidden;">
        
        <!-- Header -->
        <div style="position: absolute; top: 0; left: 0; right: 0; height: 60px; background: linear-gradient(135deg, #0d0d0d, #1a1a1a); border-bottom: 2px solid var(--accent); display: flex; align-items: center; justify-content: space-between; padding: 0 20px; z-index: 100;">
            <div>
                <div style="font-family: 'Bebas Neue'; font-size: 32px; color: var(--accent); letter-spacing: 6px;">VISUAL_LAB</div>
                <div style="font-size: 10px; color: var(--accent); opacity: 0.7; letter-spacing: 2px;">NODE-BASED VISUAL PROGRAMMING</div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="btn" onclick="showVisualLabHelp()">? HELP</button>
                <button class="btn" onclick="exitVisualLab()">‚Üê EXIT</button>
            </div>
        </div>

        <!-- Main Layout -->
        <div style="position: absolute; top: 60px; bottom: 0; left: 0; right: 0; display: flex;">
            
            <!-- Node Palette (Left Panel) -->
            <div id="node-palette" style="width: 250px; background: #0d0d0d; border-right: 1px solid var(--accent); overflow-y: auto; padding: 20px;">
                <div style="font-family: 'Bebas Neue'; color: var(--accent); font-size: 18px; letter-spacing: 2px; margin-bottom: 15px; border-bottom: 1px solid var(--accent); padding-bottom: 10px;">
                    NODE PALETTE
                </div>
                
                <!-- Generators -->
                <div style="margin-bottom: 20px;">
                    <div style="color: var(--accent); font-size: 12px; margin-bottom: 10px; opacity: 0.8;">GENERATORS</div>
                    <div class="node-item" data-type="noise" style="background: #1a1a1a; padding: 10px; margin-bottom: 8px; border: 1px solid #333; cursor: pointer; transition: 0.2s; font-size: 11px;">
                        <div style="color: var(--accent); font-weight: bold;">NOISE</div>
                        <div style="color: #666; font-size: 9px;">Perlin noise generator</div>
                    </div>
                    <div class="node-item" data-type="gradient" style="background: #1a1a1a; padding: 10px; margin-bottom: 8px; border: 1px solid #333; cursor: pointer; transition: 0.2s; font-size: 11px;">
                        <div style="color: var(--accent); font-weight: bold;">GRADIENT</div>
                        <div style="color: #666; font-size: 9px;">Color gradient</div>
                    </div>
                    <div class="node-item" data-type="circle" style="background: #1a1a1a; padding: 10px; margin-bottom: 8px; border: 1px solid #333; cursor: pointer; transition: 0.2s; font-size: 11px;">
                        <div style="color: var(--accent); font-weight: bold;">CIRCLE</div>
                        <div style="color: #666; font-size: 9px;">Circular shape</div>
                    </div>
                    <div class="node-item" data-type="grid" style="background: #1a1a1a; padding: 10px; margin-bottom: 8px; border: 1px solid #333; cursor: pointer; transition: 0.2s; font-size: 11px;">
                        <div style="color: var(--accent); font-weight: bold;">GRID</div>
                        <div style="color: #666; font-size: 9px;">Grid pattern</div>
                    </div>
                </div>

                <!-- Effects -->
                <div style="margin-bottom: 20px;">
                    <div style="color: var(--accent); font-size: 12px; margin-bottom: 10px; opacity: 0.8;">EFFECTS</div>
                    <div class="node-item" data-type="blur" style="background: #1a1a1a; padding: 10px; margin-bottom: 8px; border: 1px solid #333; cursor: pointer; transition: 0.2s; font-size: 11px;">
                        <div style="color: var(--accent); font-weight: bold;">BLUR</div>
                        <div style="color: #666; font-size: 9px;">Gaussian blur</div>
                    </div>
                    <div class="node-item" data-type="colorize" style="background: #1a1a1a; padding: 10px; margin-bottom: 8px; border: 1px solid #333; cursor: pointer; transition: 0.2s; font-size: 11px;">
                        <div style="color: var(--accent); font-weight: bold;">COLORIZE</div>
                        <div style="color: #666; font-size: 9px;">Color adjustment</div>
                    </div>
                    <div class="node-item" data-type="kaleidoscope" style="background: #1a1a1a; padding: 10px; margin-bottom: 8px; border: 1px solid #333; cursor: pointer; transition: 0.2s; font-size: 11px;">
                        <div style="color: var(--accent); font-weight: bold;">KALEIDOSCOPE</div>
                        <div style="color: #666; font-size: 9px;">Mirror effect</div>
                    </div>
                    <div class="node-item" data-type="pixelate" style="background: #1a1a1a; padding: 10px; margin-bottom: 8px; border: 1px solid #333; cursor: pointer; transition: 0.2s; font-size: 11px;">
                        <div style="color: var(--accent); font-weight: bold;">PIXELATE</div>
                        <div style="color: #666; font-size: 9px;">Pixel effect</div>
                    </div>
                </div>

                <!-- Combiners -->
                <div style="margin-bottom: 20px;">
                    <div style="color: var(--accent); font-size: 12px; margin-bottom: 10px; opacity: 0.8;">COMBINERS</div>
                    <div class="node-item" data-type="blend" style="background: #1a1a1a; padding: 10px; margin-bottom: 8px; border: 1px solid #333; cursor: pointer; transition: 0.2s; font-size: 11px;">
                        <div style="color: var(--accent); font-weight: bold;">BLEND</div>
                        <div style="color: #666; font-size: 9px;">Mix two inputs</div>
                    </div>
                    <div class="node-item" data-type="composite" style="background: #1a1a1a; padding: 10px; margin-bottom: 8px; border: 1px solid #333; cursor: pointer; transition: 0.2s; font-size: 11px;">
                        <div style="color: var(--accent); font-weight: bold;">COMPOSITE</div>
                        <div style="color: #666; font-size: 9px;">Layer images</div>
                    </div>
                </div>

                <!-- Output -->
                <div>
                    <div style="color: var(--accent); font-size: 12px; margin-bottom: 10px; opacity: 0.8;">OUTPUT</div>
                    <div class="node-item" data-type="output" style="background: #1a1a1a; padding: 10px; margin-bottom: 8px; border: 1px solid #333; cursor: pointer; transition: 0.2s; font-size: 11px;">
                        <div style="color: var(--accent); font-weight: bold;">OUTPUT</div>
                        <div style="color: #666; font-size: 9px;">Preview result</div>
                    </div>
                </div>
            </div>

            <!-- Node Canvas (Center) -->
            <div style="flex: 1; position: relative; background: repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(0,255,133,0.03) 19px, rgba(0,255,133,0.03) 20px), repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(0,255,133,0.03) 19px, rgba(0,255,133,0.03) 20px);">
                <canvas id="node-canvas" style="position: absolute; inset: 0; width: 100%; height: 100%;"></canvas>
                
                <!-- Instructions -->
                <div id="canvas-instructions" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; pointer-events: none;">
                    <div style="font-family: 'Bebas Neue'; font-size: 48px; color: var(--accent); opacity: 0.3; letter-spacing: 4px;">DRAG NODES HERE</div>
                    <div style="color: #666; font-size: 14px; margin-top: 10px;">Click nodes from the palette to add them to the canvas</div>
                </div>
            </div>

            <!-- Preview & Properties (Right Panel) -->
            <div style="width: 350px; background: #0d0d0d; border-left: 1px solid var(--accent); display: flex; flex-direction: column;">
                
                <!-- Preview -->
                <div style="height: 350px; background: #000; border-bottom: 1px solid var(--accent); position: relative;">
                    <div style="position: absolute; top: 10px; left: 10px; font-family: 'Bebas Neue'; color: var(--accent); font-size: 14px; letter-spacing: 2px;">PREVIEW</div>
                    <canvas id="preview-canvas" style="width: 100%; height: 100%;"></canvas>
                </div>

                <!-- Properties -->
                <div style="flex: 1; overflow-y: auto; padding: 20px;">
                    <div style="font-family: 'Bebas Neue'; color: var(--accent); font-size: 18px; letter-spacing: 2px; margin-bottom: 15px; border-bottom: 1px solid var(--accent); padding-bottom: 10px;">
                        PROPERTIES
                    </div>
                    
                    <div id="node-properties">
                        <div style="color: #666; font-size: 12px; padding: 20px; text-align: center;">
                            Select a node to edit properties
                        </div>
                    </div>
                </div>

                <!-- Controls -->
                <div style="padding: 15px; border-top: 1px solid var(--accent); background: #0a0a0a;">
                    <button class="btn btn-small" onclick="VISUALLAB.clearAll()" style="width: 100%; margin-bottom: 8px;">CLEAR ALL</button>
                    <button class="btn btn-small" onclick="VISUALLAB.randomPatch()" style="width: 100%; margin-bottom: 8px;">RANDOM PATCH</button>
                    <button class="btn btn-small" onclick="VISUALLAB.exportImage()" style="width: 100%;">EXPORT IMAGE</button>
                </div>
            </div>
        </div>
    </div>

    <!-- HELP OVERLAY SYSTEM -->
    <div id="help-overlay" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 10000; overflow-y: auto; padding: 40px;">
        <div style="max-width: 900px; margin: 0 auto; color: #fff;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                <h1 style="font-family: 'Bebas Neue'; font-size: 48px; color: var(--accent); letter-spacing: 4px; margin: 0;">HELP GUIDE</h1>
                <button class="btn" onclick="closeHelp()" style="font-size: 20px;">‚úï CLOSE</button>
            </div>
            <div id="help-content"></div>
        </div>
    </div>

    <!-- INTRO PAGE JAVASCRIPT -->
    <script>
        // === SONIC AUDIO SYSTEM ===
        let audioCtx;
        let masterGain;
        let ambientInterval;
        let lastCursorX = 0, lastCursorY = 0;
        let cursorSoundTimeout;

        // Initialize audio on first interaction
        function initAudio() {
            if (audioCtx) return;
            
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.35;
            masterGain.connect(audioCtx.destination);
            
            // Start ambient FX (instead of constant drone)
            startAmbientFX();
        }

        // Subtle ambient FX - random pings and echoes
        function startAmbientFX() {
            function playRandomAmbient() {
                if (!audioCtx) return;
                
                const now = audioCtx.currentTime;
                const rand = Math.random();
                
                if (rand < 0.3) {
                    // Soft ping
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    const filter = audioCtx.createBiquadFilter();
                    
                    const freq = Math.random() * 400 + 200; // 200-600 Hz
                    osc.frequency.setValueAtTime(freq, now);
                    osc.frequency.exponentialRampToValueAtTime(freq * 0.5, now + 2);
                    osc.type = 'sine';
                    
                    filter.type = 'lowpass';
                    filter.frequency.value = freq * 2;
                    filter.Q.value = 3;
                    
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.04, now + 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 3);
                    
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);
                    
                    osc.start(now);
                    osc.stop(now + 3);
                    
                } else if (rand < 0.5) {
                    // Filtered noise burst
                    const bufferSize = audioCtx.sampleRate * 0.1;
                    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    
                    const noise = audioCtx.createBufferSource();
                    noise.buffer = buffer;
                    
                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = Math.random() * 500 + 200;
                    filter.Q.value = 15;
                    
                    const gain = audioCtx.createGain();
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.03, now + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
                    
                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);
                    
                    noise.start(now);
                    
                } else if (rand < 0.7) {
                    // Deep sub pulse
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    
                    osc.frequency.setValueAtTime(40, now);
                    osc.type = 'sine';
                    
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.08, now + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 1);
                    
                    osc.connect(gain);
                    gain.connect(masterGain);
                    
                    osc.start(now);
                    osc.stop(now + 1.2);
                    
                } else {
                    // Metallic shimmer
                    const osc1 = audioCtx.createOscillator();
                    const osc2 = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    const filter = audioCtx.createBiquadFilter();
                    
                    const baseFreq = Math.random() * 1000 + 1000;
                    osc1.frequency.value = baseFreq;
                    osc2.frequency.value = baseFreq * 1.01; // Slight detuning
                    osc1.type = 'sine';
                    osc2.type = 'sine';
                    
                    filter.type = 'highpass';
                    filter.frequency.value = 800;
                    
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.02, now + 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 2);
                    
                    osc1.connect(filter);
                    osc2.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);
                    
                    osc1.start(now);
                    osc2.start(now);
                    osc1.stop(now + 2.5);
                    osc2.stop(now + 2.5);
                }
            }
            
            // Play random ambient sounds every 3-8 seconds
            function scheduleNext() {
                const delay = Math.random() * 5000 + 3000; // 3-8 seconds
                ambientInterval = setTimeout(() => {
                    playRandomAmbient();
                    scheduleNext();
                }, delay);
            }
            
            scheduleNext();
        }

        // Soft granular cursor sound with reverb
        function playCursorSound(x, y, speed) {
            if (!audioCtx) return;
            
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            const delay = audioCtx.createDelay();
            const delayGain = audioCtx.createGain();
            
            // Map cursor position to frequency (gentle range)
            const baseFreq = (x / window.innerWidth) * 200 + 200; // 200-400 Hz
            const modulation = (y / window.innerHeight) * 100;
            
            osc.frequency.setValueAtTime(baseFreq, now);
            osc.frequency.exponentialRampToValueAtTime(baseFreq + modulation, now + 0.05);
            osc.type = 'sine';
            
            // Soft envelope
            const volume = Math.min(speed / 100, 0.12);
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(volume, now + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            
            // Soft filter
            filter.type = 'lowpass';
            filter.frequency.value = baseFreq * 2;
            filter.Q.value = 2;
            
            // Subtle delay for space
            delay.delayTime.value = 0.15;
            delayGain.gain.value = 0.2;
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain); // Dry
            gain.connect(delay); // Wet
            delay.connect(delayGain);
            delayGain.connect(masterGain);
            
            osc.start(now);
            osc.stop(now + 0.2);
            
            // Random sparkle on fast movement
            if (speed > 15 && Math.random() > 0.7) {
                playSparkle(x, y);
            }
        }

        // Sparkle effect for fast cursor movement
        function playSparkle(x, y) {
            if (!audioCtx) return;
            
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            
            const freq = (x / window.innerWidth) * 2000 + 1000; // High freq
            osc.frequency.setValueAtTime(freq, now);
            osc.frequency.exponentialRampToValueAtTime(freq * 2, now + 0.05);
            osc.type = 'sine';
            
            filter.type = 'bandpass';
            filter.frequency.value = freq;
            filter.Q.value = 10;
            
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);
            
            osc.start(now);
            osc.stop(now + 0.1);
        }

        // Button hover sound - enhanced with harmonics
        function playButtonHover() {
            if (!audioCtx) return;
            
            const now = audioCtx.currentTime;
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            
            // Main tone + harmonic
            osc1.frequency.setValueAtTime(800, now);
            osc1.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
            osc2.frequency.setValueAtTime(1600, now); // Octave higher
            osc2.frequency.exponentialRampToValueAtTime(2400, now + 0.05);
            
            osc1.type = 'sine';
            osc2.type = 'sine';
            
            filter.type = 'lowpass';
            filter.frequency.value = 3000;
            filter.Q.value = 2;
            
            gain.gain.setValueAtTime(0.18, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
            
            osc1.connect(filter);
            osc2.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);
            
            osc1.start(now);
            osc2.start(now);
            osc1.stop(now + 0.15);
            osc2.stop(now + 0.15);
        }

        // Menu item hover sound - with shimmer tail
        function playMenuHover() {
            if (!audioCtx) return;
            
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const delay = audioCtx.createDelay();
            const delayGain = audioCtx.createGain();
            
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.linearRampToValueAtTime(900, now + 0.08);
            osc.type = 'triangle';
            
            // Subtle delay tail
            delay.delayTime.value = 0.1;
            delayGain.gain.value = 0.3;
            
            gain.gain.setValueAtTime(0.14, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            
            osc.connect(gain);
            gain.connect(masterGain); // Dry
            gain.connect(delay); // Wet
            delay.connect(delayGain);
            delayGain.connect(masterGain);
            
            osc.start(now);
            osc.stop(now + 0.2);
        }

        // Boot system sound - enhanced with layers
        function playBootSound() {
            if (!audioCtx) return;
            
            const now = audioCtx.currentTime;
            
            // Layer 1: Rising tone
            const osc1 = audioCtx.createOscillator();
            osc1.frequency.setValueAtTime(100, now);
            osc1.frequency.exponentialRampToValueAtTime(800, now + 0.4);
            osc1.type = 'sine';
            
            // Layer 2: Harmonic
            const osc2 = audioCtx.createOscillator();
            osc2.frequency.setValueAtTime(200, now);
            osc2.frequency.exponentialRampToValueAtTime(1200, now + 0.4);
            osc2.type = 'sine';
            
            // Layer 3: Sub bass punch
            const sub = audioCtx.createOscillator();
            sub.frequency.setValueAtTime(50, now);
            sub.frequency.exponentialRampToValueAtTime(100, now + 0.2);
            sub.type = 'sine';
            
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(500, now);
            filter.frequency.exponentialRampToValueAtTime(2000, now + 0.4);
            filter.Q.value = 2;
            
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.25, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
            
            osc1.connect(filter);
            osc2.connect(filter);
            sub.connect(gain);
            filter.connect(gain);
            gain.connect(masterGain);
            
            osc1.start(now);
            osc2.start(now);
            sub.start(now);
            osc1.stop(now + 0.5);
            osc2.stop(now + 0.5);
            sub.stop(now + 0.3);
        }

        // === CURSOR TRACKING WITH SOUND ===
        document.addEventListener('mousemove', e => {
            // Visual tracking
            gsap.to("#cursor-main", { x: e.clientX, y: e.clientY, duration: 0 });
            gsap.to("#axis-h", { top: e.clientY, duration: 0.1 });
            gsap.to("#axis-v", { left: e.clientX, duration: 0.1 });
            
            // Audio tracking (throttled)
            const speed = Math.hypot(e.clientX - lastCursorX, e.clientY - lastCursorY);
            
            if (speed > 3) { // Only play if moving fast enough
                clearTimeout(cursorSoundTimeout);
                cursorSoundTimeout = setTimeout(() => {
                    playCursorSound(e.clientX, e.clientY, speed);
                }, 50); // Throttle to 50ms
            }
            
            lastCursorX = e.clientX;
            lastCursorY = e.clientY;
        });

        // === THEME SYSTEM ===
        function setTheme(theme) {
            if (theme === 'default') {
                document.documentElement.removeAttribute('data-theme');
            } else {
                document.documentElement.setAttribute('data-theme', theme);
            }
            
            // Update active state
            document.querySelectorAll('.theme-dot').forEach(dot => {
                dot.classList.remove('active');
            });
            document.querySelector(`[data-theme="${theme}"]`).classList.add('active');
            
            // Save preference
            localStorage.setItem('dris-theme', theme);
            
            // Play theme change sound
            if (audioCtx) {
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                osc.type = 'sine';
                
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                
                osc.connect(gain);
                gain.connect(masterGain);
                
                osc.start(now);
                osc.stop(now + 0.2);
            }
        }

        // Add sound to buttons
        document.addEventListener('DOMContentLoaded', () => {
            // Load saved theme
            const savedTheme = localStorage.getItem('dris-theme') || 'default';
            setTheme(savedTheme);
            
            // Theme dots
            document.querySelectorAll('.theme-dot').forEach(dot => {
                dot.addEventListener('click', () => {
                    initAudio();
                    setTheme(dot.dataset.theme);
                });
            });
            
            // ENGAGE button
            const engageBtn = document.querySelector('#gate button');
            if (engageBtn) {
                engageBtn.addEventListener('mouseenter', () => {
                    initAudio();
                    playButtonHover();
                });
            }
            
            // Menu items
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('mouseenter', () => {
                    initAudio();
                    playMenuHover();
                });
            });
        });

        // BOOT SYSTEM
        function bootSystem() {
            initAudio();
            playBootSound();
            
            gsap.to("#gate", { 
                opacity: 0, 
                duration: 1, 
                onComplete: () => {
                    document.getElementById('gate').style.display = 'none';
                    gsap.to("#ui-root", { opacity: 1, duration: 1.5 });
                }
            });
        }

        // ENTER STUDIO
        function enterStudio() {
            try {
                // Play transition sound
                if (audioCtx) {
                    try {
                        const now = audioCtx.currentTime;
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        const filter = audioCtx.createBiquadFilter();
                        
                        osc.frequency.setValueAtTime(1200, now);
                        osc.frequency.exponentialRampToValueAtTime(60, now + 0.6);
                        osc.type = 'sawtooth';
                        
                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(2000, now);
                        filter.frequency.exponentialRampToValueAtTime(100, now + 0.6);
                        filter.Q.value = 10;
                        
                        gain.gain.setValueAtTime(0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
                        
                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(masterGain);
                        
                        osc.start(now);
                        osc.stop(now + 0.8);
                    } catch (audioError) {
                        console.error('Transition sound error:', audioError);
                    }
                }
                
                gsap.to("#ui-root", { 
                    opacity: 0, 
                    duration: 0.5, 
                    onComplete: () => {
                        try {
                            document.getElementById('ui-root').style.display = 'none';
                            document.getElementById('studio-container').classList.add('active');
                            
                            // Hide cursor effects for studio
                            const cursorMain = document.getElementById('cursor-main');
                            const axisH = document.getElementById('axis-h');
                            const axisV = document.getElementById('axis-v');
                            
                            if (cursorMain) cursorMain.style.display = 'none';
                            if (axisH) axisH.style.display = 'none';
                            if (axisV) axisV.style.display = 'none';
                            
                            document.body.style.cursor = 'auto';
                            document.body.style.overflow = 'auto';
                            
                            // Initialize STUDIO - CRITICAL!
                            if (typeof STUDIO !== 'undefined' && STUDIO.init) {
                                try {
                                    STUDIO.init();
                                    console.log('STUDIO initialized successfully');
                                } catch (initError) {
                                    console.error('STUDIO init error:', initError);
                                    alert('Error initializing studio. Please refresh the page.');
                                }
                            } else {
                                console.error('STUDIO module not found');
                            }
                            
                            // Initialize studio
                            gsap.from("#studio-container", { opacity: 0, duration: 0.5 });
                        } catch (err) {
                            console.error('Studio enter error:', err);
                            alert('Error entering studio: ' + err.message + '. Please refresh the page.');
                        }
                    }
                });
            } catch (err) {
                console.error('Critical error in enterStudio:', err);
                alert('Failed to enter studio. Please refresh the page.');
            }
        }

        // EXIT STUDIO
        function exitStudio() {
            // Play exit sound
            if (audioCtx) {
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.frequency.setValueAtTime(60, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.3);
                osc.type = 'sine';
                
                gain.gain.setValueAtTime(0.2, now); // LOUDER (was 0.1)
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                
                osc.connect(gain);
                gain.connect(masterGain);
                
                osc.start(now);
                osc.stop(now + 0.5);
            }
            
            gsap.to("#studio-container", { 
                opacity: 0, 
                duration: 0.5, 
                onComplete: () => {
                    document.getElementById('studio-container').classList.remove('active');
                    document.getElementById('ui-root').style.display = 'flex';
                    
                    // Show cursor effects again
                    document.getElementById('cursor-main').style.display = 'block';
                    document.getElementById('axis-h').style.display = 'block';
                    document.getElementById('axis-v').style.display = 'block';
                    document.body.style.cursor = 'none';
                    document.body.style.overflow = 'hidden';
                    
                    gsap.to("#ui-root", { opacity: 1, duration: 0.5 });
                }
            });
        }

        // === MOTION_AI ENGINE ===
        const MOTION = (() => {
            let canvas, gl;
            let shaderProgram;
            let animationId;
            let startTime = Date.now();
            
            // Parameters
            let params = {
                hue: 180,
                saturation: 1.0,
                brightness: 1.0,
                speed: 1.0,
                zoom: 1.0,
                complexity: 1.0,
                mode: 'fractal',
                audioReactive: false,
                autoMode: false,
                frozen: false
            };
            
            // Audio analysis
            let audioAnalyser;
            let audioDataArray;
            let bassLevel = 0;
            let trebleLevel = 0;
            
            // MIDI
            let midiAccess;
            
            // FPS counter
            let fps = 60;
            let lastFrame = Date.now();
            let frameCount = 0;
            
            // Initialize
            function init() {
                canvas = document.getElementById('motion-canvas');
                gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
                
                if (!gl) {
                    alert('WebGL not supported!');
                    return;
                }
                
                // Set canvas size
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                // Create shader program
                createShaderProgram();
                
                // Setup sliders
                setupControls();
                
                // Start animation
                animate();
            }
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                if (gl) gl.viewport(0, 0, canvas.width, canvas.height);
            }
            
            function createShaderProgram() {
                // Vertex shader (simple quad)
                const vertexShaderSource = `
                    attribute vec2 position;
                    void main() {
                        gl_Position = vec4(position, 0.0, 1.0);
                    }
                `;
                
                // Fragment shader (fractal/effects)
                const fragmentShaderSource = `
                    precision highp float;
                    
                    uniform vec2 resolution;
                    uniform float time;
                    uniform float hue;
                    uniform float saturation;
                    uniform float brightness;
                    uniform float speed;
                    uniform float zoom;
                    uniform float complexity;
                    uniform float bass;
                    uniform float treble;
                    uniform int mode;
                    
                    // HSV to RGB conversion
                    vec3 hsv2rgb(vec3 c) {
                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                    }
                    
                    // Fractal mode
                    vec3 fractalMode(vec2 uv) {
                        vec2 c = (uv - 0.5) * zoom * 3.0;
                        c.x += sin(time * speed * 0.1) * 0.5;
                        c.y += cos(time * speed * 0.1) * 0.5;
                        
                        vec2 z = c;
                        float iter = 0.0;
                        
                        for(int i = 0; i < 100; i++) {
                            if(length(z) > 4.0) break;
                            z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
                            iter += 1.0;
                        }
                        
                        float colorValue = iter / (100.0 * complexity);
                        colorValue += bass * 0.3;
                        
                        return hsv2rgb(vec3(hue/360.0 + colorValue, saturation, brightness * colorValue));
                    }
                    
                    // Particle mode
                    vec3 particleMode(vec2 uv) {
                        vec2 p = (uv - 0.5) * zoom * 2.0;
                        float t = time * speed * 0.5;
                        
                        float color = 0.0;
                        
                        for(float i = 0.0; i < 20.0; i++) {
                            float angle = i * 0.628 + t;
                            vec2 pos = vec2(sin(angle), cos(angle)) * (0.3 + bass * 0.2);
                            float dist = length(p - pos);
                            color += 0.01 / (dist + 0.01);
                        }
                        
                        color *= complexity;
                        color += treble * 0.2;
                        
                        return hsv2rgb(vec3(hue/360.0 + color * 0.1, saturation, brightness * color));
                    }
                    
                    // Plasma mode
                    vec3 plasmaMode(vec2 uv) {
                        vec2 p = uv * zoom * 5.0;
                        float t = time * speed * 0.3;
                        
                        float v = sin(p.x + t);
                        v += sin(p.y + t);
                        v += sin(p.x + p.y + t);
                        v += sin(sqrt(p.x*p.x + p.y*p.y) + t);
                        v *= 0.25;
                        
                        v += bass * 0.5;
                        
                        return hsv2rgb(vec3(hue/360.0 + v, saturation, brightness * (0.5 + v * 0.5)));
                    }
                    
                    // Cyberpunk grid
                    vec3 cyberpunkMode(vec2 uv) {
                        vec2 p = uv * zoom * 10.0;
                        p.y += time * speed * 0.5;
                        
                        vec2 grid = fract(p);
                        vec2 id = floor(p);
                        
                        float d = min(grid.x, grid.y);
                        d = min(d, 1.0 - grid.x);
                        d = min(d, 1.0 - grid.y);
                        
                        float glow = 0.02 / d;
                        glow += bass * 2.0;
                        
                        float flicker = sin(id.x * id.y + time * 10.0) * 0.5 + 0.5;
                        
                        return hsv2rgb(vec3(hue/360.0, saturation, brightness * glow * flicker));
                    }
                    
                    void main() {
                        vec2 uv = gl_FragCoord.xy / resolution.xy;
                        vec3 color;
                        
                        if(mode == 0) color = fractalMode(uv);
                        else if(mode == 1) color = particleMode(uv);
                        else if(mode == 2) color = plasmaMode(uv);
                        else if(mode == 3) color = cyberpunkMode(uv);
                        else color = fractalMode(uv);
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `;
                
                // Compile shaders
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, vertexShaderSource);
                gl.compileShader(vertexShader);
                
                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, fragmentShaderSource);
                gl.compileShader(fragmentShader);
                
                // Create program
                shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);
                gl.useProgram(shaderProgram);
                
                // Create quad
                const vertices = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1
                ]);
                
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                
                const positionLoc = gl.getAttribLocation(shaderProgram, 'position');
                gl.enableVertexAttribArray(positionLoc);
                gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
            }
            
            function setupControls() {
                const hueSlider = document.getElementById('hue-slider');
                const speedSlider = document.getElementById('speed-slider');
                const zoomSlider = document.getElementById('zoom-slider');
                
                hueSlider.addEventListener('input', (e) => {
                    params.hue = parseFloat(e.target.value);
                    document.getElementById('hue-val').textContent = Math.round(params.hue);
                });
                
                speedSlider.addEventListener('input', (e) => {
                    params.speed = parseFloat(e.target.value);
                    document.getElementById('speed-val').textContent = params.speed.toFixed(1);
                });
                
                zoomSlider.addEventListener('input', (e) => {
                    params.zoom = parseFloat(e.target.value);
                    document.getElementById('zoom-val').textContent = params.zoom.toFixed(1);
                });
            }
            
            function animate() {
                if (params.frozen) {
                    animationId = requestAnimationFrame(animate);
                    return;
                }
                
                // Update FPS
                frameCount++;
                const now = Date.now();
                if (now - lastFrame >= 1000) {
                    fps = frameCount;
                    document.getElementById('fps-display').textContent = fps;
                    frameCount = 0;
                    lastFrame = now;
                }
                
                // Get audio data if reactive
                if (params.audioReactive && audioAnalyser) {
                    audioAnalyser.getByteFrequencyData(audioDataArray);
                    
                    // Calculate bass (0-100 Hz)
                    let bassSum = 0;
                    for (let i = 0; i < 10; i++) {
                        bassSum += audioDataArray[i];
                    }
                    bassLevel = bassSum / (10 * 255);
                    
                    // Calculate treble (2kHz+)
                    let trebleSum = 0;
                    for (let i = 100; i < 150; i++) {
                        trebleSum += audioDataArray[i];
                    }
                    trebleLevel = trebleSum / (50 * 255);
                }
                
                // Set uniforms
                const time = (Date.now() - startTime) / 1000.0;
                
                gl.uniform2f(gl.getUniformLocation(shaderProgram, 'resolution'), canvas.width, canvas.height);
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'time'), time);
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'hue'), params.hue);
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'saturation'), params.saturation);
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'brightness'), params.brightness);
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'speed'), params.speed);
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'zoom'), params.zoom);
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'complexity'), params.complexity);
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'bass'), bassLevel);
                gl.uniform1f(gl.getUniformLocation(shaderProgram, 'treble'), trebleLevel);
                
                // Set mode
                const modeMap = {
                    'fractal': 0,
                    'particles': 1,
                    'plasma': 2,
                    'cyberpunk': 3,
                    'cosmic': 1,
                    'liquid': 2,
                    'glitch': 0,
                    'vaporwave': 3
                };
                gl.uniform1i(gl.getUniformLocation(shaderProgram, 'mode'), modeMap[params.mode] || 0);
                
                // Draw
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                animationId = requestAnimationFrame(animate);
            }
            
            // Public methods
            return {
                init,
                
                loadPreset: function(preset) {
                    params.mode = preset;
                    document.getElementById('mode-display').textContent = preset.toUpperCase();
                    
                    // Preset-specific parameters
                    if (preset === 'cyberpunk') {
                        params.hue = 280;
                        params.speed = 0.8;
                    } else if (preset === 'cosmic') {
                        params.hue = 260;
                        params.speed = 0.5;
                    } else if (preset === 'vaporwave') {
                        params.hue = 310;
                        params.speed = 0.3;
                    }
                    
                    // Update sliders
                    document.getElementById('hue-slider').value = params.hue;
                    document.getElementById('hue-val').textContent = Math.round(params.hue);
                },
                
                randomize: function() {
                    params.hue = Math.random() * 360;
                    params.speed = Math.random() * 3 + 0.5;
                    params.zoom = Math.random() * 2 + 0.5;
                    
                    document.getElementById('hue-slider').value = params.hue;
                    document.getElementById('speed-slider').value = params.speed;
                    document.getElementById('zoom-slider').value = params.zoom;
                    document.getElementById('hue-val').textContent = Math.round(params.hue);
                    document.getElementById('speed-val').textContent = params.speed.toFixed(1);
                    document.getElementById('zoom-val').textContent = params.zoom.toFixed(1);
                },
                
                toggleAudio: async function() {
                    params.audioReactive = !params.audioReactive;
                    const btn = document.getElementById('audio-btn');
                    const display = document.getElementById('audio-display');
                    
                    if (params.audioReactive) {
                        btn.textContent = 'AUDIO: CONNECTING...';
                        
                        try {
                            // Try to get microphone access
                            const stream = await navigator.mediaDevices.getUserMedia({ 
                                audio: {
                                    echoCancellation: false,
                                    noiseSuppression: false,
                                    autoGainControl: false
                                } 
                            });
                            
                            // Create audio context if not exists
                            if (!audioAnalyser) {
                                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                                audioAnalyser = audioCtx.createAnalyser();
                                audioAnalyser.fftSize = 256;
                                audioAnalyser.smoothingTimeConstant = 0.8;
                                audioDataArray = new Uint8Array(audioAnalyser.frequencyBinCount);
                                
                                // Connect microphone to analyser
                                const source = audioCtx.createMediaStreamSource(stream);
                                source.connect(audioAnalyser);
                            }
                            
                            btn.textContent = 'AUDIO: ON (MIC)';
                            btn.classList.add('active');
                            display.textContent = 'ON (MIC)';
                            
                            alert('üéµ Audio Reactive ON!\n\nListening to your MICROPHONE.\n\nüí° HOW TO USE:\n\n1. Play music from your speakers\n2. Make beats in AUDIO_STUDIO\n3. Sing/make sounds into mic\n\nVisuals will react:\n‚Ä¢ Bass = Zoom pulse\n‚Ä¢ Treble = Extra glow\n\nTIP: Turn up your volume!');
                            
                        } catch (err) {
                            alert('‚ùå Microphone Access Denied!\n\nTo enable Audio Reactive:\n\n1. Click the üîí icon in your browser\n2. Allow microphone access\n3. Refresh the page\n4. Try again!\n\nOR:\n‚Ä¢ Play music near your device\n‚Ä¢ Make beats in AUDIO_STUDIO\n‚Ä¢ The mic will pick up the sound!');
                            
                            params.audioReactive = false;
                            btn.textContent = 'AUDIO: OFF';
                            btn.classList.remove('active');
                            display.textContent = 'OFF';
                        }
                    } else {
                        btn.textContent = 'AUDIO: OFF';
                        btn.classList.remove('active');
                        display.textContent = 'OFF';
                    }
                },
                
                toggleAuto: function() {
                    params.autoMode = !params.autoMode;
                    const btn = document.getElementById('auto-btn');
                    const display = document.getElementById('auto-display');
                    
                    if (params.autoMode) {
                        btn.textContent = 'AUTO: ON';
                        btn.classList.add('active');
                        display.textContent = 'ON';
                    } else {
                        btn.textContent = 'AUTO: OFF';
                        btn.classList.remove('active');
                        display.textContent = 'OFF';
                    }
                },
                
                freeze: function() {
                    params.frozen = !params.frozen;
                },
                
                generateFromPrompt: function() {
                    const prompt = document.getElementById('motion-prompt').value.toLowerCase();
                    
                    // Simple keyword detection
                    if (prompt.includes('fractal') || prompt.includes('mandel')) {
                        this.loadPreset('fractal');
                    } else if (prompt.includes('particle') || prompt.includes('star')) {
                        this.loadPreset('particles');
                    } else if (prompt.includes('plasma') || prompt.includes('wave')) {
                        this.loadPreset('plasma');
                    } else if (prompt.includes('cyber') || prompt.includes('grid')) {
                        this.loadPreset('cyberpunk');
                    } else if (prompt.includes('cosmic') || prompt.includes('nebula')) {
                        this.loadPreset('cosmic');
                    } else if (prompt.includes('vapor')) {
                        this.loadPreset('vaporwave');
                    }
                    
                    // Extract color keywords
                    if (prompt.includes('purple')) params.hue = 280;
                    else if (prompt.includes('blue')) params.hue = 220;
                    else if (prompt.includes('cyan')) params.hue = 180;
                    else if (prompt.includes('green')) params.hue = 120;
                    else if (prompt.includes('red')) params.hue = 0;
                    else if (prompt.includes('pink')) params.hue = 320;
                    
                    document.getElementById('hue-slider').value = params.hue;
                    document.getElementById('hue-val').textContent = Math.round(params.hue);
                },
                
                connectMIDI: async function() {
                    try {
                        if (!navigator.requestMIDIAccess) {
                            alert('MIDI not supported in this browser!\n\nTry Chrome, Edge, or Opera.\nSafari and Firefox don\'t support Web MIDI yet.');
                            return;
                        }
                        
                        const midiAccess = await navigator.requestMIDIAccess();
                        
                        // Check if any MIDI devices are connected
                        const inputs = Array.from(midiAccess.inputs.values());
                        
                        if (inputs.length === 0) {
                            alert('No MIDI devices found!\n\n1. Connect your MIDI controller\n2. Refresh the page\n3. Try "Connect MIDI" again\n\nMake sure your MIDI device is powered on!');
                            document.getElementById('midi-status-motion').innerHTML = '‚óã No devices found';
                            document.getElementById('midi-status-motion').style.color = '#ff0055';
                            return;
                        }
                        
                        document.getElementById('midi-status-motion').innerHTML = `‚óè Connected: ${inputs[0].name || 'MIDI Device'}`;
                        document.getElementById('midi-status-motion').style.color = 'var(--accent)';
                        
                        // Show success message
                        const msg = `MIDI Connected!\n\nDevice: ${inputs[0].name || 'Unknown'}\n\nControls:\nCC1 = Hue\nCC2 = Saturation\nCC3 = Speed\nCC4 = Zoom\nCC5 = Complexity\n\nNotes:\nC = Fractal\nD = Particles\nE = Plasma\nF = Cyberpunk\n\nTwist your knobs!`;
                        alert(msg);
                        
                        for (let input of midiAccess.inputs.values()) {
                            input.onmidimessage = (msg) => {
                                const [status, data1, data2] = msg.data;
                                const normalized = data2 / 127;
                                
                                // CC mappings
                                if (status === 176) { // Control Change
                                    if (data1 === 1) {
                                        params.hue = normalized * 360;
                                        document.getElementById('hue-slider').value = params.hue;
                                        document.getElementById('hue-val').textContent = Math.round(params.hue);
                                    }
                                    else if (data1 === 2) {
                                        params.saturation = normalized;
                                    }
                                    else if (data1 === 3) {
                                        params.speed = normalized * 5;
                                        document.getElementById('speed-slider').value = params.speed;
                                        document.getElementById('speed-val').textContent = params.speed.toFixed(1);
                                    }
                                    else if (data1 === 4) {
                                        params.zoom = normalized * 3;
                                        document.getElementById('zoom-slider').value = params.zoom;
                                        document.getElementById('zoom-val').textContent = params.zoom.toFixed(1);
                                    }
                                    else if (data1 === 5) {
                                        params.complexity = normalized * 2;
                                    }
                                    
                                    // Visual feedback - flash the status
                                    document.getElementById('midi-status-motion').style.opacity = '1';
                                    setTimeout(() => {
                                        document.getElementById('midi-status-motion').style.opacity = '0.7';
                                    }, 50);
                                }
                                
                                // Note On - trigger presets (FIXED: was using 'cc' instead of note number)
                                if (status === 144 && data2 > 0) { // Note On
                                    const notePresets = {
                                        60: 'fractal',    // C
                                        62: 'particles',  // D
                                        64: 'plasma',     // E
                                        65: 'cyberpunk',  // F
                                        67: 'cosmic',     // G
                                        69: 'liquid',     // A
                                        71: 'glitch',     // B
                                    };
                                    
                                    // FIXED: use data1 (note number) and call MOTION.loadPreset
                                    if (notePresets[data1]) {
                                        MOTION.loadPreset(notePresets[data1]);
                                    }
                                }
                            };
                        }
                    } catch (err) {
                        alert('MIDI Error: ' + err.message + '\n\nMake sure:\n1. Your browser supports Web MIDI\n2. Your MIDI device is connected\n3. You granted MIDI permissions');
                        document.getElementById('midi-status-motion').innerHTML = '‚óã Connection failed';
                        document.getElementById('midi-status-motion').style.color = '#ff0055';
                    }
                },
                
                detectMIDI: async function() {
                    try {
                        if (!navigator.requestMIDIAccess) {
                            alert('MIDI not supported in this browser!\n\nTry Chrome, Edge, or Opera.\nSafari and Firefox don\'t support Web MIDI yet.');
                            return;
                        }
                        
                        this.midiAccess = await navigator.requestMIDIAccess();
                        this.midiInputs = Array.from(this.midiAccess.inputs.values());
                        
                        const selectEl = document.getElementById('midi-device-select-motion');
                        const connectBtn = document.getElementById('midi-connect-btn-motion');
                        const statusEl = document.getElementById('midi-status-motion');
                        
                        if (this.midiInputs.length === 0) {
                            alert('No MIDI devices found!\n\n1. Connect your MIDI controller\n2. Refresh the page\n3. Try "DETECT DEVICES" again');
                            statusEl.innerHTML = '‚óã No devices found';
                            statusEl.style.color = '#ff0055';
                            selectEl.innerHTML = '<option value="">No devices found</option>';
                            return;
                        }
                        
                        // Populate dropdown
                        selectEl.innerHTML = '';
                        this.midiInputs.forEach((input, index) => {
                            const option = document.createElement('option');
                            option.value = index;
                            option.textContent = input.name || `MIDI Device ${index + 1}`;
                            selectEl.appendChild(option);
                        });
                        
                        selectEl.disabled = false;
                        connectBtn.disabled = false;
                        statusEl.innerHTML = `Found ${this.midiInputs.length} device(s) - Select one`;
                        statusEl.style.color = 'var(--accent)';
                        
                    } catch (err) {
                        alert('MIDI Error: ' + err.message);
                        document.getElementById('midi-status-motion').innerHTML = '‚óã Detection failed';
                        document.getElementById('midi-status-motion').style.color = '#ff0055';
                    }
                },
                
                connectSelectedMIDI: function() {
                    const selectEl = document.getElementById('midi-device-select-motion');
                    const statusEl = document.getElementById('midi-status-motion');
                    const selectedIndex = parseInt(selectEl.value);
                    
                    if (isNaN(selectedIndex) || !this.midiInputs[selectedIndex]) {
                        alert('Please select a MIDI device first!');
                        return;
                    }
                    
                    // Disconnect all
                    this.midiInputs.forEach(input => {
                        input.onmidimessage = null;
                    });
                    
                    // Connect to selected
                    const selectedDevice = this.midiInputs[selectedIndex];
                    selectedDevice.onmidimessage = (msg) => {
                        const [status, data1, data2] = msg.data;
                        const normalized = data2 / 127;
                        
                        // CC mappings
                        if (status === 176) { // Control Change
                            if (data1 === 1) {
                                params.hue = normalized * 360;
                                document.getElementById('hue-slider').value = params.hue;
                                document.getElementById('hue-val').textContent = Math.round(params.hue);
                            }
                            else if (data1 === 2) {
                                params.saturation = normalized;
                            }
                            else if (data1 === 3) {
                                params.speed = normalized * 5;
                                document.getElementById('speed-slider').value = params.speed;
                                document.getElementById('speed-val').textContent = params.speed.toFixed(1);
                            }
                            else if (data1 === 4) {
                                params.zoom = normalized * 3;
                                document.getElementById('zoom-slider').value = params.zoom;
                                document.getElementById('zoom-val').textContent = params.zoom.toFixed(1);
                            }
                            else if (data1 === 5) {
                                params.complexity = normalized * 2;
                            }
                            
                            statusEl.style.opacity = '1';
                            setTimeout(() => {
                                statusEl.style.opacity = '0.7';
                            }, 50);
                        }
                        
                        // Note On
                        if (status === 144 && data2 > 0) {
                            const notePresets = {
                                60: 'fractal',
                                62: 'particles',
                                64: 'plasma',
                                65: 'cyberpunk',
                                67: 'cosmic',
                                69: 'liquid',
                                71: 'glitch',
                            };
                            
                            if (notePresets[data1]) {
                                MOTION.loadPreset(notePresets[data1]);
                            }
                        }
                    };
                    
                    statusEl.innerHTML = `‚óè Connected: ${selectedDevice.name}`;
                    statusEl.style.color = 'var(--accent)';
                    alert(`MIDI Connected!\n\nüéπ Device: ${selectedDevice.name}\n\nControls:\nCC1 = Hue\nCC2 = Saturation\nCC3 = Speed\nCC4 = Zoom\nCC5 = Complexity\n\nNotes:\nC-G = Trigger presets`);
                }
            };
        })();

        // ENTER MOTION_AI
        function enterMotionAI() {
            gsap.to("#ui-root", { 
                opacity: 0, 
                duration: 0.5, 
                onComplete: () => {
                    document.getElementById('ui-root').style.display = 'none';
                    document.getElementById('motion-ai-container').style.display = 'block';
                    
                    // Hide cursor effects
                    document.getElementById('cursor-main').style.display = 'none';
                    document.getElementById('axis-h').style.display = 'none';
                    document.getElementById('axis-v').style.display = 'none';
                    document.body.style.cursor = 'auto';
                    document.body.style.overflow = 'hidden';
                    
                    // Initialize MOTION_AI
                    MOTION.init();
                    
                    gsap.from("#motion-ai-container", { opacity: 0, duration: 0.5 });
                }
            });
        }

        // EXIT MOTION_AI
        function exitMotionAI() {
            gsap.to("#motion-ai-container", { 
                opacity: 0, 
                duration: 0.5, 
                onComplete: () => {
                    document.getElementById('motion-ai-container').style.display = 'none';
                    document.getElementById('ui-root').style.display = 'flex';
                    
                    // Show cursor effects again
                    document.getElementById('cursor-main').style.display = 'block';
                    document.getElementById('axis-h').style.display = 'block';
                    document.getElementById('axis-v').style.display = 'block';
                    document.body.style.cursor = 'none';
                    
                    gsap.to("#ui-root", { opacity: 1, duration: 0.5 });
                }
            });
        }

        // === VISUAL_LAB ENGINE ===
        const VISUALLAB = (() => {
            let canvas, ctx;
            let previewCanvas, previewCtx;
            let nodes = [];
            let connections = [];
            let selectedNode = null;
            let draggingNode = null;
            let dragOffset = { x: 0, y: 0 };
            let nextNodeId = 1;

            // Node class
            class Node {
                constructor(type, x, y) {
                    this.id = nextNodeId++;
                    this.type = type;
                    this.x = x;
                    this.y = y;
                    this.width = 150;
                    this.height = 80;
                    this.inputs = this.getInputs(type);
                    this.outputs = this.getOutputs(type);
                    this.params = this.getDefaultParams(type);
                }

                getInputs(type) {
                    if (type === 'noise' || type === 'gradient' || type === 'circle' || type === 'grid') return [];
                    if (type === 'blend' || type === 'composite') return ['input1', 'input2'];
                    if (type === 'output') return ['input'];
                    return ['input'];
                }

                getOutputs(type) {
                    if (type === 'output') return [];
                    return ['output'];
                }

                getDefaultParams(type) {
                    switch(type) {
                        case 'noise':
                            return { scale: 50, time: 0 };
                        case 'gradient':
                            return { color1: '#ff00ff', color2: '#00ffff', angle: 0 };
                        case 'circle':
                            return { radius: 100, x: 0, y: 0, color: '#00ff85' };
                        case 'grid':
                            return { size: 50, thickness: 2, color: '#00ff85' };
                        case 'blur':
                            return { amount: 5 };
                        case 'colorize':
                            return { hue: 180, saturation: 100 };
                        case 'kaleidoscope':
                            return { segments: 6 };
                        case 'pixelate':
                            return { pixelSize: 10 };
                        case 'blend':
                            return { mode: 'normal', opacity: 0.5 };
                        case 'composite':
                            return { mode: 'over' };
                        default:
                            return {};
                    }
                }

                draw(ctx) {
                    // Node body
                    ctx.fillStyle = selectedNode === this ? '#1a1a1a' : '#0d0d0d';
                    ctx.strokeStyle = selectedNode === this ? getComputedStyle(document.documentElement).getPropertyValue('--accent') : '#333';
                    ctx.lineWidth = selectedNode === this ? 2 : 1;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.strokeRect(this.x, this.y, this.width, this.height);

                    // Title
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent');
                    ctx.font = '12px "Bebas Neue"';
                    ctx.fillText(this.type.toUpperCase(), this.x + 10, this.y + 20);

                    // Input/output sockets
                    this.inputs.forEach((input, i) => {
                        const y = this.y + 35 + i * 20;
                        ctx.fillStyle = '#333';
                        ctx.beginPath();
                        ctx.arc(this.x, y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#666';
                        ctx.font = '10px monospace';
                        ctx.fillText(input, this.x + 10, y + 4);
                    });

                    this.outputs.forEach((output, i) => {
                        const y = this.y + 35 + i * 20;
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent');
                        ctx.beginPath();
                        ctx.arc(this.x + this.width, y, 5, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }

                isInside(mx, my) {
                    return mx >= this.x && mx <= this.x + this.width &&
                           my >= this.y && my <= this.y + this.height;
                }
            }

            function init() {
                canvas = document.getElementById('node-canvas');
                ctx = canvas.getContext('2d');
                previewCanvas = document.getElementById('preview-canvas');
                previewCtx = previewCanvas.getContext('2d');

                // Set canvas sizes
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                previewCanvas.width = 350;
                previewCanvas.height = 350;

                // Setup event listeners
                setupEventListeners();

                // Start rendering
                render();
            }

            function setupEventListeners() {
                // Node palette clicks
                document.querySelectorAll('.node-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const type = item.dataset.type;
                        addNode(type, 100 + Math.random() * 200, 100 + Math.random() * 200);
                        document.getElementById('canvas-instructions').style.display = 'none';
                    });

                    item.addEventListener('mouseenter', function() {
                        this.style.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--accent');
                        this.style.background = '#222';
                    });

                    item.addEventListener('mouseleave', function() {
                        this.style.borderColor = '#333';
                        this.style.background = '#1a1a1a';
                    });
                });

                // Canvas interactions
                canvas.addEventListener('mousedown', handleMouseDown);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseup', handleMouseUp);

                // Window resize
                window.addEventListener('resize', () => {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                });
            }

            function handleMouseDown(e) {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;

                // Check if clicking on a node
                for (let i = nodes.length - 1; i >= 0; i--) {
                    if (nodes[i].isInside(mx, my)) {
                        selectedNode = nodes[i];
                        draggingNode = nodes[i];
                        dragOffset.x = mx - nodes[i].x;
                        dragOffset.y = my - nodes[i].y;
                        updatePropertiesPanel();
                        return;
                    }
                }

                selectedNode = null;
                updatePropertiesPanel();
            }

            function handleMouseMove(e) {
                if (draggingNode) {
                    const rect = canvas.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;
                    draggingNode.x = mx - dragOffset.x;
                    draggingNode.y = my - dragOffset.y;
                }
            }

            function handleMouseUp(e) {
                draggingNode = null;
            }

            function addNode(type, x, y) {
                const node = new Node(type, x, y);
                nodes.push(node);
                selectedNode = node;
                updatePropertiesPanel();
                updatePreview();
            }

            function updatePropertiesPanel() {
                const panel = document.getElementById('node-properties');
                
                if (!selectedNode) {
                    panel.innerHTML = '<div style="color: #666; font-size: 12px; padding: 20px; text-align: center;">Select a node to edit properties</div>';
                    return;
                }

                let html = `<div style="margin-bottom: 15px;">
                    <div style="color: var(--accent); font-size: 14px; margin-bottom: 10px; font-family: 'Bebas Neue'; letter-spacing: 1px;">${selectedNode.type.toUpperCase()}</div>
                    <div style="color: #666; font-size: 10px; margin-bottom: 15px;">ID: ${selectedNode.id}</div>
                </div>`;

                // Add parameter controls based on node type
                Object.keys(selectedNode.params).forEach(key => {
                    const value = selectedNode.params[key];
                    html += `<div style="margin-bottom: 12px;">
                        <label style="color: var(--accent); font-size: 11px; display: block; margin-bottom: 5px; opacity: 0.8;">${key.toUpperCase()}</label>`;
                    
                    if (typeof value === 'number') {
                        html += `<input type="range" min="0" max="255" value="${value}" 
                            onchange="VISUALLAB.updateNodeParam(${selectedNode.id}, '${key}', parseFloat(this.value))"
                            style="width: 100%;">
                            <div style="color: #666; font-size: 10px; margin-top: 3px;">${value}</div>`;
                    } else if (typeof value === 'string' && value.startsWith('#')) {
                        html += `<input type="color" value="${value}" 
                            onchange="VISUALLAB.updateNodeParam(${selectedNode.id}, '${key}', this.value)"
                            style="width: 100%; height: 30px;">`;
                    }
                    
                    html += `</div>`;
                });

                html += `<button class="btn btn-small" onclick="VISUALLAB.deleteNode(${selectedNode.id})" style="width: 100%; margin-top: 20px; background: #ff0055; border-color: #ff0055;">DELETE NODE</button>`;

                panel.innerHTML = html;
            }

            function render() {
                // Clear canvas
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw connections
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent');
                ctx.lineWidth = 2;
                connections.forEach(conn => {
                    const from = nodes.find(n => n.id === conn.from);
                    const to = nodes.find(n => n.id === conn.to);
                    if (from && to) {
                        ctx.beginPath();
                        ctx.moveTo(from.x + from.width, from.y + 40);
                        ctx.lineTo(to.x, to.y + 40);
                        ctx.stroke();
                    }
                });

                // Draw nodes
                nodes.forEach(node => node.draw(ctx));

                requestAnimationFrame(render);
            }

            function updatePreview() {
                // Simple preview rendering
                previewCtx.fillStyle = '#000';
                previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);

                // Render based on nodes
                nodes.forEach(node => {
                    if (node.type === 'noise') {
                        renderNoise(previewCtx, node.params);
                    } else if (node.type === 'gradient') {
                        renderGradient(previewCtx, node.params);
                    } else if (node.type === 'circle') {
                        renderCircle(previewCtx, node.params);
                    } else if (node.type === 'grid') {
                        renderGrid(previewCtx, node.params);
                    }
                });
            }

            function renderNoise(ctx, params) {
                const imageData = ctx.createImageData(ctx.canvas.width, ctx.canvas.height);
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const value = Math.random() * 255;
                    imageData.data[i] = value;
                    imageData.data[i + 1] = value;
                    imageData.data[i + 2] = value;
                    imageData.data[i + 3] = 255;
                }
                ctx.putImageData(imageData, 0, 0);
            }

            function renderGradient(ctx, params) {
                const gradient = ctx.createLinearGradient(0, 0, ctx.canvas.width, ctx.canvas.height);
                gradient.addColorStop(0, params.color1);
                gradient.addColorStop(1, params.color2);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            }

            function renderCircle(ctx, params) {
                ctx.fillStyle = params.color;
                ctx.beginPath();
                ctx.arc(ctx.canvas.width / 2 + params.x, ctx.canvas.height / 2 + params.y, params.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            function renderGrid(ctx, params) {
                ctx.strokeStyle = params.color;
                ctx.lineWidth = params.thickness;
                for (let x = 0; x < ctx.canvas.width; x += params.size) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, ctx.canvas.height);
                    ctx.stroke();
                }
                for (let y = 0; y < ctx.canvas.height; y += params.size) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(ctx.canvas.width, y);
                    ctx.stroke();
                }
            }

            return {
                init,
                addNode,
                updateNodeParam: function(nodeId, param, value) {
                    const node = nodes.find(n => n.id === nodeId);
                    if (node) {
                        node.params[param] = value;
                        updatePreview();
                    }
                },
                deleteNode: function(nodeId) {
                    nodes = nodes.filter(n => n.id !== nodeId);
                    selectedNode = null;
                    updatePropertiesPanel();
                    updatePreview();
                },
                clearAll: function() {
                    if (confirm('Clear all nodes?')) {
                        nodes = [];
                        connections = [];
                        selectedNode = null;
                        updatePropertiesPanel();
                        updatePreview();
                        document.getElementById('canvas-instructions').style.display = 'block';
                    }
                },
                randomPatch: function() {
                    this.clearAll();
                    const types = ['noise', 'gradient', 'circle', 'grid'];
                    for (let i = 0; i < 3; i++) {
                        const type = types[Math.floor(Math.random() * types.length)];
                        addNode(type, 100 + i * 200, 100 + Math.random() * 200);
                    }
                },
                exportImage: function() {
                    const link = document.createElement('a');
                    link.download = 'visual_lab_' + Date.now() + '.png';
                    link.href = previewCanvas.toDataURL();
                    link.click();
                }
            };
        })();

        // ENTER VISUAL_LAB
        function enterVisualLab() {
            gsap.to("#ui-root", { 
                opacity: 0, 
                duration: 0.5, 
                onComplete: () => {
                    document.getElementById('ui-root').style.display = 'none';
                    document.getElementById('visual-lab-container').style.display = 'block';
                    
                    // Hide cursor effects
                    document.getElementById('cursor-main').style.display = 'none';
                    document.getElementById('axis-h').style.display = 'none';
                    document.getElementById('axis-v').style.display = 'none';
                    document.body.style.cursor = 'auto';
                    
                    // Initialize VISUAL_LAB
                    VISUALLAB.init();
                    
                    gsap.from("#visual-lab-container", { opacity: 0, duration: 0.5 });
                }
            });
        }

        // EXIT VISUAL_LAB
        function exitVisualLab() {
            gsap.to("#visual-lab-container", { 
                opacity: 0, 
                duration: 0.5, 
                onComplete: () => {
                    document.getElementById('visual-lab-container').style.display = 'none';
                    document.getElementById('ui-root').style.display = 'flex';
                    
                    // Show cursor effects again
                    document.getElementById('cursor-main').style.display = 'block';
                    document.getElementById('axis-h').style.display = 'block';
                    document.getElementById('axis-v').style.display = 'block';
                    document.body.style.cursor = 'none';
                    
                    gsap.to("#ui-root", { opacity: 1, duration: 0.5 });
                }
            });
        }
    </script>

    <!-- HELP SYSTEM FUNCTIONS -->
    <script>
        function closeHelp() {
            document.getElementById('help-overlay').style.display = 'none';
        }

        function showStudioHelp() {
            const content = `
                <div style="font-size: 16px; line-height: 1.8;">
                    <h2 style="color: var(--accent); font-family: 'Bebas Neue'; font-size: 32px; margin: 20px 0;">üéµ AUDIO_STUDIO GUIDE</h2>
                    
                    <div style="background: #1a1a1a; padding: 20px; margin: 20px 0; border-left: 4px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">ü•Å HOW TO MAKE BEATS</h3>
                        <ol style="color: #ccc;">
                            <li><strong>Select a Drum Kit:</strong> Choose from dropdown (909, 808, Trap, LoFi, etc.)</li>
                            <li><strong>Click Squares:</strong> Each row is a sound (Kick, Snare, HiHat, Perc)</li>
                            <li><strong>Click Squares to Activate:</strong> Create your pattern (16 steps)</li>
                            <li><strong>Press PLAY Button:</strong> Your beat plays!</li>
                            <li><strong>Adjust BPM:</strong> Use slider to change tempo (60-180 BPM)</li>
                        </ol>
                    </div>

                    <div style="background: #1a1a1a; padding: 20px; margin: 20px 0; border-left: 4px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">üé∏ HOW TO ADD BASSLINE</h3>
                        <ol style="color: #ccc;">
                            <li><strong>Click LOAD PRESET:</strong> Try "Acid", "Techno", or "House"</li>
                            <li><strong>Or Create Custom:</strong> Click steps to add notes</li>
                            <li><strong>Drag Up/Down:</strong> Change pitch of each note</li>
                            <li><strong>Double-Click:</strong> Remove a note</li>
                            <li><strong>Press PLAY BASS:</strong> Bass plays with drums!</li>
                            <li><strong>Press RECORD:</strong> Saves 4-bar WAV file</li>
                        </ol>
                    </div>

                    <div style="background: #1a1a1a; padding: 20px; margin: 20px 0; border-left: 4px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">üéπ CURSOR SYNTH</h3>
                        <ul style="color: #ccc;">
                            <li><strong>Move Cursor:</strong> Left/Right = Pitch, Up/Down = Filter</li>
                            <li><strong>Click & Hold:</strong> Sustain the note</li>
                            <li><strong>Change Wave:</strong> Try Sine, Square, Sawtooth, Triangle</li>
                            <li><strong>Add Effects:</strong> Adjust LFO, Distortion, Delay, Reverb</li>
                        </ul>
                    </div>

                    <div style="background: #1a1a1a; padding: 20px; margin: 20px 0; border-left: 4px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">üíª LIVE CODING</h3>
                        <ul style="color: #ccc;">
                            <li><strong>Type Code:</strong> Write JavaScript in the editor</li>
                            <li><strong>Press EXECUTE:</strong> Runs your code immediately</li>
                            <li><strong>Press LOOP:</strong> Code repeats every 500ms</li>
                            <li><strong>Try Examples:</strong> Load preset examples to learn</li>
                        </ul>
                        <p style="color: #888; font-size: 14px; margin: 10px 0 0 0;">Example: <code style="color: var(--accent);">freq(440); play(0.5);</code> = Play A440 note</p>
                    </div>

                    <div style="background: #1a1a1a; padding: 20px; margin: 20px 0; border-left: 4px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">üé® VISUAL REACTOR</h3>
                        <ul style="color: #ccc;">
                            <li><strong>Click CYCLE MODE:</strong> Try all 6 visual modes</li>
                            <li><strong>Adjust Intensity:</strong> Makes visuals stronger</li>
                            <li><strong>Adjust Speed:</strong> Animation speed</li>
                            <li><strong>Random Colors:</strong> New color palette</li>
                        </ul>
                    </div>

                    <div style="background: #0d0d0d; padding: 20px; margin: 30px 0; border: 2px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">üí° QUICK START</h3>
                        <ol style="color: #ccc; font-size: 18px;">
                            <li>Select "Glitch IDM" drum kit</li>
                            <li>Click some squares to make a pattern</li>
                            <li>Press PLAY</li>
                            <li>Load "Acid" bassline preset</li>
                            <li>Press PLAY BASS</li>
                            <li>üéâ You made a beat!</li>
                        </ol>
                    </div>
                </div>
            `;
            document.getElementById('help-content').innerHTML = content;
            document.getElementById('help-overlay').style.display = 'block';
        }

        function showMotionHelp() {
            const content = `
                <div style="font-size: 16px; line-height: 1.8;">
                    <h2 style="color: var(--accent); font-family: 'Bebas Neue'; font-size: 32px; margin: 20px 0;">üé¨ MOTION_AI GUIDE</h2>
                    
                    <div style="background: #1a1a1a; padding: 20px; margin: 20px 0; border-left: 4px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">üåå BASIC CONTROLS</h3>
                        <ul style="color: #ccc;">
                            <li><strong>PRESET Dropdown:</strong> Choose from 8 visual modes
                                <ul style="margin-top: 10px; color: #888;">
                                    <li>FRACTAL TUNNEL - Mandelbrot fractal zoom</li>
                                    <li>PARTICLE FIELD - Rotating star particles</li>
                                    <li>PLASMA WAVES - Flowing color waves</li>
                                    <li>CYBERPUNK GRID - Neon grid matrix</li>
                                    <li>COSMIC NEBULA - Space vibes</li>
                                    <li>LIQUID METAL - Metallic flow</li>
                                    <li>GLITCH ART - Digital corruption</li>
                                    <li>VAPORWAVE - 80s aesthetic</li>
                                </ul>
                            </li>
                            <li><strong>HUE Slider (0-360):</strong> Changes colors through full spectrum</li>
                            <li><strong>SPEED Slider (0.1-5x):</strong> Animation speed</li>
                            <li><strong>ZOOM Slider (0.5-3x):</strong> Zoom in/out effect</li>
                        </ul>
                    </div>

                    <div style="background: #1a1a1a; padding: 20px; margin: 20px 0; border-left: 4px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">‚úçÔ∏è TEXT PROMPTS</h3>
                        <ol style="color: #ccc;">
                            <li><strong>Type Description:</strong> In the text box, type what you want</li>
                            <li><strong>Press GENERATE:</strong> Visuals change based on keywords</li>
                        </ol>
                        <p style="color: #888; margin-top: 15px;"><strong>Example Prompts:</strong></p>
                        <ul style="color: #666; font-size: 14px;">
                            <li>"cosmic nebula purple" ‚Üí Purple cosmic mode</li>
                            <li>"cyberpunk grid cyan" ‚Üí Cyan cyberpunk grid</li>
                            <li>"fractal tunnel blue fast" ‚Üí Blue fast fractal</li>
                            <li>"plasma waves red slow" ‚Üí Red slow plasma</li>
                        </ul>
                    </div>

                    <div style="background: #1a1a1a; padding: 20px; margin: 20px 0; border-left: 4px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">üîä AUDIO REACTIVE MODE</h3>
                        <ol style="color: #ccc;">
                            <li><strong>Click "AUDIO: OFF"</strong></li>
                            <li><strong>Allow Microphone:</strong> Browser asks permission ‚Üí Click Allow</li>
                            <li><strong>Make Sound:</strong>
                                <ul style="margin-top: 10px; color: #888;">
                                    <li>Play music from speakers</li>
                                    <li>Make beats in AUDIO_STUDIO</li>
                                    <li>Sing/talk into mic</li>
                                    <li>Clap your hands</li>
                                </ul>
                            </li>
                            <li><strong>Watch Reactions:</strong>
                                <ul style="margin-top: 10px; color: #888;">
                                    <li>Bass ‚Üí Zoom pulse</li>
                                    <li>Treble ‚Üí Extra glow</li>
                                    <li>Loud ‚Üí Stronger effect</li>
                                </ul>
                            </li>
                        </ol>
                    </div>

                    <div style="background: #1a1a1a; padding: 20px; margin: 20px 0; border-left: 4px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">üé≤ OTHER BUTTONS</h3>
                        <ul style="color: #ccc;">
                            <li><strong>RANDOMIZE:</strong> Random settings applied instantly</li>
                            <li><strong>AUTO:</strong> Slowly cycles through modes automatically</li>
                            <li><strong>FREEZE:</strong> Pause animation (click again to resume)</li>
                        </ul>
                    </div>

                    <div style="background: #0d0d0d; padding: 20px; margin: 30px 0; border: 2px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">üí° QUICK START</h3>
                        <ol style="color: #ccc; font-size: 18px;">
                            <li>Select "CYBERPUNK GRID" preset</li>
                            <li>Click "AUDIO: OFF" to enable audio reactive</li>
                            <li>Allow microphone permission</li>
                            <li>Play music or make beats in AUDIO_STUDIO</li>
                            <li>Twist HUE slider while music plays</li>
                            <li>üéâ Live visual performance!</li>
                        </ol>
                    </div>

                    <div style="background: #1a1a1a; padding: 15px; margin: 20px 0;">
                        <p style="color: #888; font-size: 13px; margin: 0;"><strong>Note:</strong> MIDI connection requires Chrome/Edge/Opera and a connected MIDI controller. If MIDI doesn't work, don't worry - all features work great without it!</p>
                    </div>
                </div>
            `;
            document.getElementById('help-content').innerHTML = content;
            document.getElementById('help-overlay').style.display = 'block';
        }

        function showVisualLabHelp() {
            const content = `
                <div style="font-size: 16px; line-height: 1.8;">
                    <h2 style="color: var(--accent); font-family: 'Bebas Neue'; font-size: 32px; margin: 20px 0;">üé® VISUAL_LAB GUIDE</h2>
                    
                    <div style="background: #1a1a1a; padding: 20px; margin: 20px 0; border-left: 4px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">üì¶ ADDING NODES</h3>
                        <ol style="color: #ccc;">
                            <li><strong>Look at Left Panel:</strong> See list of available nodes</li>
                            <li><strong>Click Any Node:</strong> It appears on the canvas (center)</li>
                            <li><strong>Drag to Move:</strong> Click and drag node to reposition</li>
                            <li><strong>Add More:</strong> Keep clicking to add multiple nodes</li>
                        </ol>
                    </div>

                    <div style="background: #1a1a1a; padding: 20px; margin: 20px 0; border-left: 4px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">‚öôÔ∏è EDITING PARAMETERS</h3>
                        <ol style="color: #ccc;">
                            <li><strong>Select a Node:</strong> Click the node on canvas (it highlights)</li>
                            <li><strong>Right Panel Shows Properties:</strong> See node parameters</li>
                            <li><strong>Adjust Sliders:</strong> Change values</li>
                            <li><strong>Pick Colors:</strong> Click color picker boxes</li>
                            <li><strong>Preview Updates:</strong> See changes in real-time!</li>
                        </ol>
                    </div>

                    <div style="background: #1a1a1a; padding: 20px; margin: 20px 0; border-left: 4px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">üé® NODE TYPES</h3>
                        <p style="color: #ccc;"><strong>GENERATORS (Create visuals):</strong></p>
                        <ul style="color: #888; margin-bottom: 20px;">
                            <li><strong style="color: var(--accent);">NOISE</strong> - Random texture (organic, clouds)</li>
                            <li><strong style="color: var(--accent);">GRADIENT</strong> - Color blend (backgrounds)</li>
                            <li><strong style="color: var(--accent);">CIRCLE</strong> - Circular shape (masks, mandalas)</li>
                            <li><strong style="color: var(--accent);">GRID</strong> - Grid pattern (cyberpunk grids)</li>
                        </ul>
                        
                        <p style="color: #ccc;"><strong>EFFECTS (Transform visuals):</strong></p>
                        <ul style="color: #888; margin-bottom: 20px;">
                            <li><strong style="color: var(--accent);">BLUR</strong> - Soften image</li>
                            <li><strong style="color: var(--accent);">COLORIZE</strong> - Change colors</li>
                            <li><strong style="color: var(--accent);">KALEIDOSCOPE</strong> - Mirror effect (psychedelic)</li>
                            <li><strong style="color: var(--accent);">PIXELATE</strong> - Pixel art style</li>
                        </ul>
                        
                        <p style="color: #ccc;"><strong>COMBINERS (Mix visuals):</strong></p>
                        <ul style="color: #888;">
                            <li><strong style="color: var(--accent);">BLEND</strong> - Mix two inputs</li>
                            <li><strong style="color: var(--accent);">COMPOSITE</strong> - Layer images</li>
                        </ul>
                    </div>

                    <div style="background: #1a1a1a; padding: 20px; margin: 20px 0; border-left: 4px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">üíæ EXPORTING</h3>
                        <ol style="color: #ccc;">
                            <li><strong>Create Your Art:</strong> Add nodes and adjust parameters</li>
                            <li><strong>Check Preview:</strong> Make sure it looks good</li>
                            <li><strong>Click "EXPORT IMAGE":</strong> Downloads PNG file</li>
                            <li><strong>Find in Downloads:</strong> File is named visual_lab_[timestamp].png</li>
                        </ol>
                    </div>

                    <div style="background: #1a1a1a; padding: 20px; margin: 20px 0; border-left: 4px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">üé≤ QUICK ACTIONS</h3>
                        <ul style="color: #ccc;">
                            <li><strong>CLEAR ALL:</strong> Remove all nodes (starts fresh)</li>
                            <li><strong>RANDOM PATCH:</strong> Creates 3 random nodes instantly</li>
                            <li><strong>DELETE NODE:</strong> Select node ‚Üí Click DELETE in properties</li>
                        </ul>
                    </div>

                    <div style="background: #0d0d0d; padding: 20px; margin: 30px 0; border: 2px solid var(--accent);">
                        <h3 style="color: var(--accent); margin-top: 0;">üí° QUICK START EXAMPLES</h3>
                        
                        <p style="color: var(--accent); font-size: 18px; margin: 20px 0 10px 0;">Example 1: Vaporwave Gradient</p>
                        <ol style="color: #ccc;">
                            <li>Click GRADIENT node</li>
                            <li>Set Color 1 to Pink</li>
                            <li>Set Color 2 to Cyan</li>
                            <li>Click GRID node</li>
                            <li>Set Grid Color to White</li>
                            <li>üéâ Vaporwave aesthetic!</li>
                        </ol>

                        <p style="color: var(--accent); font-size: 18px; margin: 20px 0 10px 0;">Example 2: Mandala</p>
                        <ol style="color: #ccc;">
                            <li>Click CIRCLE node</li>
                            <li>Set Radius to 100</li>
                            <li>Pick a bright color</li>
                            <li>Click KALEIDOSCOPE node</li>
                            <li>Set Segments to 8</li>
                            <li>üéâ Psychedelic mandala!</li>
                        </ol>

                        <p style="color: var(--accent); font-size: 18px; margin: 20px 0 10px 0;">Example 3: Quick Art</p>
                        <ol style="color: #ccc;">
                            <li>Click "RANDOM PATCH" button</li>
                            <li>See instant creation</li>
                            <li>Adjust any parameters you like</li>
                            <li>Click EXPORT IMAGE</li>
                            <li>üéâ Done!</li>
                        </ol>
                    </div>
                </div>
            `;
            document.getElementById('help-content').innerHTML = content;
            document.getElementById('help-overlay').style.display = 'block';
        }
        
        // Global error handler
        window.addEventListener('error', function(e) {
            console.error('Global error:', e.error);
            console.error('Error message:', e.message);
            console.error('At:', e.filename, 'line', e.lineno);
        });
        
        window.addEventListener('unhandledrejection', function(e) {
            console.error('Unhandled promise rejection:', e.reason);
        });
        
        // Log when page is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, DRIS ready');
        });
    </script>
</body>
</html>
